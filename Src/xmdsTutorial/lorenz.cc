// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_ALL_LOG_LEVELS)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
          printf("%s:%i: ", __FILE__, __LINE__); \
      printf(__VA_ARGS__); \
      fflush(stdout); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE
#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   field dimensionless defines
#define _dimensionless_ndims 0


// vector position defines
#define _dimensionless_position_ncomponents 3

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 0


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 1


#define _mg0_output_lattice_t ((int)5001)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 3


// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;


real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
};

// ********************************************************
//   'Globals' element globals

#line 17 "lorenz.xmds"

real sigma = 10.0;
real b = 8.0/3.0;
real r = 28.0;

#line 238 "lorenz.cc"

// ********************************************************
//   field dimensionless globals
// vector position globals
size_t _dimensionless_position_alloc_size = 0;
real* _dimensionless_position = NULL;
real* _active_dimensionless_position = NULL;

// ********************************************************
//   segment 1 (RK89 adaptive-step integrator) globals
real* _segment1_akafield_dimensionless_position;
real* _segment1_akbfield_dimensionless_position;
real* _segment1_akcfield_dimensionless_position;
real* _segment1_akdfield_dimensionless_position;
real* _segment1_akefield_dimensionless_position;
real* _segment1_akffield_dimensionless_position;
real* _segment1_akgfield_dimensionless_position;
real* _segment1_akhfield_dimensionless_position;
real* _segment1_akifield_dimensionless_position;
real* _segment1_akjfield_dimensionless_position;
real* _segment1_initial_dimensionless_position;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   field dimensionless function prototypes
void _dimensionless_position_initialise();

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (RK89 adaptive-step integrator) function prototypes
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent);
void _segment1();
inline void _segment1_ip_evolve(int _exponent);
real _segment1_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter);
real _segment1_dimensionless_position_timestep_error(real* _checkfield);
bool _segment1_dimensionless_position_reset(real* _reset_to);

void _segment1_dimensionless_operators_evaluate_operator0(real _step);

// ********************************************************
//   output function prototypes
void _write_output();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'lorenz' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
    
  
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t) * _mg0_output_raw_ncomponents);
  _dimensionless_position_alloc_size = MAX(_dimensionless_position_alloc_size, (1) * _dimensionless_position_ncomponents);
  
  _dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _active_dimensionless_position = _dimensionless_position;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  
  
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  xmds_free(_dimensionless_position);
  _active_dimensionless_position = _dimensionless_position = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Default Simulation Driver function implementations
void _segment0()
{
  t = 0.0;
  
  _mg0_output_raw_initialise();
  _active_dimensionless_position = _dimensionless_position;
  _dimensionless_position_initialise();
  _mg0_output_index_t = 0;
  _mg0_sample();
  _segment1();
  
  _mg0_process();
}


// ********************************************************
//   field dimensionless function implementations
// initialisation for vector position
void _dimensionless_position_initialise()
{
  
  long _dimensionless_position_index_pointer = 0;
  #define x _active_dimensionless_position[_dimensionless_position_index_pointer + 0]
  #define y _active_dimensionless_position[_dimensionless_position_index_pointer + 1]
  #define z _active_dimensionless_position[_dimensionless_position_index_pointer + 2]
  // The purpose of the following define is to give a (somewhat helpful) compile-time error
  // if the user has attempted to use the propagation dimension variable in the initialisation
  // block of a <vector> element. If they're trying to do this, what they really want is a 
  // <computed_vector> instead.
  #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
  
  // ********** Initialisation code ***************
  #line 39 "lorenz.xmds"
  
  x = y = z = 1.0;
  
  #line 451 "lorenz.cc"
  // **********************************************
  #undef t
  
  #undef x
  #undef y
  #undef z
}

// ********************************************************
//   segment 1 (RK89 adaptive-step integrator) function implementations
inline void _segment1_calculate_delta_a(real _step)
{
  
  
  // Delta A propagation operator for field dimensionless
  _segment1_dimensionless_operators_evaluate_operator0(_step);
  
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}


void _segment1()
{
  real _step = 20.0/(real)1000;
  real _old_step = _step;
  real _min_step = _step;
  real _max_step = _step;
  long _attempted_steps = 0;
  long _unsuccessful_steps = 0;
  
  real _tolerance = 1e-07;
  
  real _error, _last_norm_error = 1.0;
  real _segment1_dimensionless_position_error;
  
  bool _discard = false;
  bool _break_next = false;
  
  bool _next_sample_flag[3];
  for (long _i0 = 0; _i0 < 3; _i0++)
    _next_sample_flag[_i0] = false;
  
  long _next_sample_counter[1];
  for (long _i0 = 0; _i0 < 1; _i0++)
    _next_sample_counter[_i0] = 1;
  
  real _t_local = 0.0;
  
  real _t_break_next = _segment1_setup_sampling(_next_sample_flag, _next_sample_counter);
  
  if ( (_t_local + _step)*(1.0 + _EPSILON) >= _t_break_next) {
    _break_next = true;
    _step = _t_break_next - _t_local;
  }
  
  _segment1_akafield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akbfield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akcfield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akdfield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akefield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akffield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akgfield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akhfield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akifield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_akjfield_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  _segment1_initial_dimensionless_position = (real*) xmds_malloc(sizeof(real) * MAX(_dimensionless_position_alloc_size,1));
  real* _akafield_dimensionless_position = _segment1_akafield_dimensionless_position;
  real* _akbfield_dimensionless_position = _segment1_akbfield_dimensionless_position;
  real* _akcfield_dimensionless_position = _segment1_akcfield_dimensionless_position;
  real* _akdfield_dimensionless_position = _segment1_akdfield_dimensionless_position;
  real* _akefield_dimensionless_position = _segment1_akefield_dimensionless_position;
  real* _akffield_dimensionless_position = _segment1_akffield_dimensionless_position;
  real* _akgfield_dimensionless_position = _segment1_akgfield_dimensionless_position;
  real* _akhfield_dimensionless_position = _segment1_akhfield_dimensionless_position;
  real* _akifield_dimensionless_position = _segment1_akifield_dimensionless_position;
  real* _akjfield_dimensionless_position = _segment1_akjfield_dimensionless_position;
  real* _initial_dimensionless_position = _segment1_initial_dimensionless_position;
  
  
  // Runge Kutta method constants 
  real _a_raw[16];
  real _a[16];
  real _b[16][16];
  real _c[16];
  real _cs[16];
  real _d[16];
  
  for (unsigned long _i0 = 0; _i0 < 16; _i0++) {
    _a_raw[_i0] = _c[_i0] = _d[_i0] = 0.0;
    for (unsigned long _i1 = 0; _i1 < 16; _i1++)
     _b[_i0][_i1] = 0.0;
  }
  
  _a_raw[1]  = 0.02173913043478260869565217391304347;
  _a_raw[2]  = 0.09629581047800066670113001679819925;
  _a_raw[3]  = 0.14444371571700100005169502519729888;
  _a_raw[4]  = 0.52205882352941176470588235294117647;
  _a_raw[5]  = 0.22842443612863469578031459099794265;
  _a_raw[6]  = 0.54360353589933733219171338103002937;
  _a_raw[7]  = 0.64335664335664335664335664335664335;
  _a_raw[8]  = 0.48251748251748251748251748251748251;
  _a_raw[9]  = 0.06818181818181818181818181818181818;
  _a_raw[10] = 0.25060827250608272506082725060827250;
  _a_raw[11] = 0.66736715965600568968278165443304378;
  _a_raw[12] = 0.85507246376811594202898550724637681;
  _a_raw[13] = 0.89795918367346938775510204081632653;
  _a_raw[14] = 1.0;
  _a_raw[15] = 1.0;
  
  _a[0] = 0.0;
  for (unsigned long _i0 = 1; _i0 < 16; _i0++)
    _a[_i0] = _a_raw[_i0] - _a_raw[_i0 - 1];
  
  _b[1][0]   = 1.0/46.0;
  _b[2][0]   =-0.11698050118114486205818241524969622;
  _b[2][1]   = 0.21327631165914552875931243204789548;
  _b[3][0]   = 0.03611092892925025001292375629932472;
  _b[3][2]   = 0.10833278678775075003877126889797416;
  _b[4][0]   = 1.57329743908138605107331820072051125;
  _b[4][2]   =-5.98400943754042002888532938159655553;
  _b[4][3]   = 4.93277082198844574251789353381722074;
  _b[5][0]   = 0.05052046351120380909008334360006234;
  _b[5][3]   = 0.17686653884807108146683657390397612;
  _b[5][4]   = 0.00103743376935980522339467349390418;
  _b[6][0]   = 0.10543148021953768958529340893598138;
  _b[6][3]   =-0.16042415162569842979496486916719383;
  _b[6][4]   = 0.11643956912829316045688724281285250;
  _b[6][5]   = 0.48215663817720491194449759844838932;
  _b[7][0]   = 0.07148407148407148407148407148407148;
  _b[7][5]   = 0.32971116090443908023196389566296464;
  _b[7][6]   = 0.24216141096813279233990867620960722;
  _b[8][0]   = 0.07162368881118881118881118881118881;
  _b[8][5]   = 0.32859867301674234161492268975519694;
  _b[8][6]   = 0.11622213117906185418927311444060725;
  _b[8][7]   =-0.03392701048951048951048951048951048;
  _b[9][0]   = 0.04861540768024729180628870095388582;
  _b[9][5]   = 0.03998502200331629058445317782406268;
  _b[9][6]   = 0.10715724786209388876739304914053506;
  _b[9][7]   =-0.02177735985419485163815426357369818;
  _b[9][8]   =-0.10579849950964443770179884616296721;
  _b[10][0]  =-0.02540141041535143673515871979014924;
  _b[10][5]  = 1.0/30.0;
  _b[10][6]  =-0.16404854760069182073503553020238782;
  _b[10][7]  = 0.03410548898794737788891414566528526;
  _b[10][8]  = 0.15836825014108792658008718465091487;
  _b[10][9]  = 0.21425115805975734472868683695127609;
  _b[11][0]  = 0.00584833331460742801095934302256470;
  _b[11][5]  =-0.53954170547283522916525526480339109;
  _b[11][6]  = 0.20128430845560909506500331018201158;
  _b[11][7]  = 0.04347222773254789483240207937678906;
  _b[11][8]  =-0.00402998571475307250775349983910179;
  _b[11][9]  = 0.16541535721570612771420482097898952;
  _b[11][10] = 0.79491862412512344573322086551518180;
  _b[12][0]  =-0.39964965968794892497157706711861448;
  _b[12][5]  =-3.79096577568393158554742638116249372;
  _b[12][6]  =-0.40349325653530103387515807815498044;
  _b[12][7]  =-2.82463879530435263378049668286220715;
  _b[12][8]  = 1.04226892772185985533374283289821416;
  _b[12][9]  = 1.12510956420436603974237036536924078;
  _b[12][10] = 3.32746188718986816186934832571938138;
  _b[12][11] = 2.77897957186355606325818219255783627;
  _b[13][0]  = 0.39545306350085237157098218205756922;
  _b[13][5]  = 5.82534730759650564865380791881446903;
  _b[13][6]  =-0.36527452339161313311889856846974452;
  _b[13][7]  = 1.18860324058346533283780076203192232;
  _b[13][8]  = 0.57970467638357921347110271762687972;
  _b[13][9]  =-0.86824862589087693262676988867897834;
  _b[13][10] =-5.20227677296454721392873650976792184;
  _b[13][11] =-0.79895541420753382543211121058675915;
  _b[13][12] = 0.14360623206363792632792463778889008;
  _b[14][0]  = 8.49173149061346398013352206978380938;
  _b[14][5]  = 86.32213734729036800877634194386790750;
  _b[14][6]  = 1.02560575501091662034511526187393241;
  _b[14][7]  = 85.77427969817339941806831550695235092;
  _b[14][8]  =-13.98699305104110611795532466113248067;
  _b[14][9]  =-20.71537405501426352265946477613161883;
  _b[14][10] =-72.16597156619946800281180102605140463;
  _b[14][11] =-76.71211139107806345587696023064419687;
  _b[14][12] = 4.22319427707298828839851258893735507;
  _b[14][13] =-1.25649850482823521641825667745565428;
  _b[15][0]  =-0.42892119881959353241190195318730008;
  _b[15][5]  =-9.16865700950084689999297912545025359;
  _b[15][6]  = 1.08317616770620939241547721530003920;
  _b[15][7]  =-1.23501525358323653198215832293981810;
  _b[15][8]  =-1.21438272617593906232943856422371019;
  _b[15][9]  = 1.37226168507232166621351243731869914;
  _b[15][10] = 9.15723239697162418155377135344394113;
  _b[15][11] = 1.30616301842220047563298585480401671;
  _b[15][12] =-0.25285618808937955976690569433069974;
  _b[15][13] = 0.38099910799663987066763679926508552;
  
  _c[0]  = 0.01490902081978461022483617102382552;
  _c[7]  =-0.20408044692054151258349120934134791;
  _c[8]  = 0.22901438600570447264772469337066476;
  _c[9]  = 0.12800558251147375669208211573729202;
  _c[10] = 0.22380626846054143649770066956485937;
  _c[11] = 0.39553165293700054420552389156421651;
  _c[12] = 0.05416646758806981196568364538360743;
  _c[13] = 0.12691439652445903685643385312168037;
  _c[14] =-0.00052539244262118876455834655383035;
  _c[15] = 1.0/31.0;
  
  _cs[0]  = 0.00653047880643482012034413441159249;
  _cs[7]  =-2.31471038197461347517552506241529830;
  _cs[8]  = 0.43528227238866280799530900822377013;
  _cs[9]  = 0.14907947287101933118545845390618763;
  _cs[10] = 0.17905535442235532311850533252768020;
  _cs[11] = 2.53400872222767706921176214508820825;
  _cs[12] =-0.55430437423209112896721332268159015;
  _cs[13] = 0.56924788787870083224213506297615260;
  _cs[14] =-0.03644749690427461198884026816573513;
  _cs[15] = 1.0/31.0;
  
  _d[0] = 1.0-_b[15][5]/_b[14][5];
  _d[1] = _b[15][0]-_b[14][0]*_b[15][5]/_b[14][5];
  _d[2] = _b[15][5]/_b[14][5];
  _d[3] = _b[15][6]-_b[14][6]*_b[15][5]/_b[14][5];
  _d[4] = _b[15][7]-_b[14][7]*_b[15][5]/_b[14][5];
  _d[5] = _b[15][8]-_b[14][8]*_b[15][5]/_b[14][5];
  _d[6] = _b[15][9]-_b[14][9]*_b[15][5]/_b[14][5];
  _d[7] = _b[15][10]-_b[14][10]*_b[15][5]/_b[14][5];
  _d[8] = _b[15][11]-_b[14][11]*_b[15][5]/_b[14][5];
  _d[9] = _b[15][12]-_b[14][12]*_b[15][5]/_b[14][5];
  _d[10] = _b[15][13]-_b[14][13]*_b[15][5]/_b[14][5];
  
  do {
    
    do {
      
      
      // Step 1
      
      memcpy(_akafield_dimensionless_position, _dimensionless_position, sizeof(real) * _dimensionless_position_alloc_size);
      
      _segment1_calculate_nonconstant_ip_fields(_step, 1);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(1);
      
      _active_dimensionless_position = _akafield_dimensionless_position;
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(1);
      
      // Step 2
      
      t += _a[1] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akbfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[1][0]*_akafield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akbfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 2);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-2);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(2);
      
      // Step 3
      
      t += _a[2] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akcfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[2][0]*_akafield_dimensionless_position[_i0] + _b[2][1]*_akbfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akcfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 3);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-3);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(3);
      
      // Step 4
      
      t += _a[3] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akdfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[3][0]*_akafield_dimensionless_position[_i0] + _b[3][1]*_akbfield_dimensionless_position[_i0]
            + _b[3][2]*_akcfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akdfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 4);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-4);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(4);
      
      // Step 5
      
      t += _a[4] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akefield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[4][0]*_akafield_dimensionless_position[_i0] + _b[4][1]*_akbfield_dimensionless_position[_i0]
            + _b[4][2]*_akcfield_dimensionless_position[_i0] + _b[4][3]*_akdfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akefield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 5);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-5);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(5);
      
      // Step 6
      
      t += _a[5] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akifield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[5][0]*_akafield_dimensionless_position[_i0] + _b[5][3]*_akdfield_dimensionless_position[_i0]
            + _b[5][4]*_akefield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akifield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 6);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-6);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(6);
      
      // Step 7
      
      t += _a[6] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akjfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[6][0]*_akafield_dimensionless_position[_i0] + _b[6][3]*_akdfield_dimensionless_position[_i0]
            + _b[6][4]*_akefield_dimensionless_position[_i0] + _b[6][5]*_akifield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akjfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 7);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-7);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(7);
      
      // Step 8
      
      t += _a[7] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akbfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[7][0]*_akafield_dimensionless_position[_i0] + _b[7][5]*_akifield_dimensionless_position[_i0]
            + _b[7][6]*_akjfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akbfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 8);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-8);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(8);
      
      // Step 9
      
      t += _a[8] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akcfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[8][0]*_akafield_dimensionless_position[_i0] + _b[8][5]*_akifield_dimensionless_position[_i0]
            + _b[8][6]*_akjfield_dimensionless_position[_i0]+ _b[8][7]*_akbfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akcfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 9);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-9);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(9);
      
      // Step 10
      
      t += _a[9] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akdfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[9][0]*_akafield_dimensionless_position[_i0] + _b[9][5]*_akifield_dimensionless_position[_i0]
            + _b[9][6]*_akjfield_dimensionless_position[_i0]+ _b[9][7]*_akbfield_dimensionless_position[_i0]+ _b[9][8]*_akcfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akdfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 10);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-10);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(10);
      
      // Step 11
      
      t += _a[10] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akefield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[10][0]*_akafield_dimensionless_position[_i0] + _b[10][5]*_akifield_dimensionless_position[_i0]
            + _b[10][6]*_akjfield_dimensionless_position[_i0]+ _b[10][7]*_akbfield_dimensionless_position[_i0] + _b[10][8]*_akcfield_dimensionless_position[_i0]
            + _b[10][9]*_akdfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akefield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 11);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-11);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(11);
      
      // Step 12
      
      t += _a[11] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akffield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[11][0]*_akafield_dimensionless_position[_i0] + _b[11][5]*_akifield_dimensionless_position[_i0]
            + _b[11][6]*_akjfield_dimensionless_position[_i0] + _b[11][7]*_akbfield_dimensionless_position[_i0] + _b[11][8]*_akcfield_dimensionless_position[_i0]
            + _b[11][9]*_akdfield_dimensionless_position[_i0] + _b[11][10]*_akefield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akffield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 12);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-12);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(12);
      
      // Step 13
      
      t += _a[12] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akgfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[12][0]*_akafield_dimensionless_position[_i0] + _b[12][5]*_akifield_dimensionless_position[_i0]
            + _b[12][6]*_akjfield_dimensionless_position[_i0]+ _b[12][7]*_akbfield_dimensionless_position[_i0] + _b[12][8]*_akcfield_dimensionless_position[_i0]
            + _b[12][9]*_akdfield_dimensionless_position[_i0] + _b[12][10]*_akefield_dimensionless_position[_i0] + _b[12][11]*_akffield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akgfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 13);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-13);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(13);
      
      // Step 14
      
      t += _a[13] * _step;
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akhfield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[13][0]*_akafield_dimensionless_position[_i0] + _b[13][5]*_akifield_dimensionless_position[_i0]
            + _b[13][6]*_akjfield_dimensionless_position[_i0]+ _b[13][7]*_akbfield_dimensionless_position[_i0] + _b[13][8]*_akcfield_dimensionless_position[_i0]
            + _b[13][9]*_akdfield_dimensionless_position[_i0] + _b[13][10]*_akefield_dimensionless_position[_i0] + _b[13][11]*_akffield_dimensionless_position[_i0]
            + _b[13][12]*_akgfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _akhfield_dimensionless_position;
      
      _segment1_calculate_nonconstant_ip_fields(_step, 14);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(-14);
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment1_ip_evolve(14);
      
      // Step 15 and 16 combined to reduce memory use 
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akifield_dimensionless_position[_i0] = _dimensionless_position[_i0] + _b[14][0]*_akafield_dimensionless_position[_i0] + _b[14][5]*_akifield_dimensionless_position[_i0]
            + _b[14][6]*_akjfield_dimensionless_position[_i0]+ _b[14][7]*_akbfield_dimensionless_position[_i0] + _b[14][8]*_akcfield_dimensionless_position[_i0]
            + _b[14][9]*_akdfield_dimensionless_position[_i0] + _b[14][10]*_akefield_dimensionless_position[_i0] + _b[14][11]*_akffield_dimensionless_position[_i0]
            + _b[14][12]*_akgfield_dimensionless_position[_i0] + _b[14][13]*_akhfield_dimensionless_position[_i0];
      }
      
      
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akjfield_dimensionless_position[_i0] = _d[0]*_dimensionless_position[_i0]
              + _d[1]*_akafield_dimensionless_position[_i0]
              + _d[2]*_akifield_dimensionless_position[_i0]
              + _d[3]*_akjfield_dimensionless_position[_i0]
              + _d[4]*_akbfield_dimensionless_position[_i0]
              + _d[5]*_akcfield_dimensionless_position[_i0]
              + _d[6]*_akdfield_dimensionless_position[_i0]
              + _d[7]*_akefield_dimensionless_position[_i0]
              + _d[8]*_akffield_dimensionless_position[_i0]
              + _d[9]*_akgfield_dimensionless_position[_i0]
              + _d[10]*_akhfield_dimensionless_position[_i0];
      }
      
      
      t += _a[14] * _step;
      
      _active_dimensionless_position = _akifield_dimensionless_position;
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      t += _a[15] * _step;
      
      _active_dimensionless_position = _akjfield_dimensionless_position;
      
      // a_k=G[a_k, t]
      _segment1_calculate_delta_a(_step);
      
      // Take full step
      
      // ai = a
      memcpy(_initial_dimensionless_position, _dimensionless_position, sizeof(real) * _dimensionless_position_alloc_size);
      
      // a = a + etc
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _dimensionless_position[_i0] += _c[0]*_akafield_dimensionless_position[_i0] + _c[7]*_akbfield_dimensionless_position[_i0] + _c[8]*_akcfield_dimensionless_position[_i0]
            + _c[9]*_akdfield_dimensionless_position[_i0] + _c[10]*_akefield_dimensionless_position[_i0] + _c[11]*_akffield_dimensionless_position[_i0]
            + _c[12]*_akgfield_dimensionless_position[_i0] + _c[13]*_akhfield_dimensionless_position[_i0] + _c[14]*_akifield_dimensionless_position[_i0]
            + _c[15]*_akjfield_dimensionless_position[_i0];
      }
      
      
      // a* = a + etc
      for (long _i0 = 0; _i0 < (1) * _dimensionless_position_ncomponents; _i0++) {
        _akafield_dimensionless_position[_i0] = _initial_dimensionless_position[_i0] + _cs[0]*_akafield_dimensionless_position[_i0] + _cs[7]*_akbfield_dimensionless_position[_i0]
            + _cs[8]*_akcfield_dimensionless_position[_i0] + _cs[9]*_akdfield_dimensionless_position[_i0] + _cs[10]*_akefield_dimensionless_position[_i0]
            + _cs[11]*_akffield_dimensionless_position[_i0] + _cs[12]*_akgfield_dimensionless_position[_i0] + _cs[13]*_akhfield_dimensionless_position[_i0]
            + _cs[14]*_akifield_dimensionless_position[_i0] + _cs[15]*_akjfield_dimensionless_position[_i0];
      }
      
      
      _active_dimensionless_position = _dimensionless_position;
      
      
      
      _error = 0.0;
      
      _segment1_dimensionless_position_error = _segment1_dimensionless_position_timestep_error(_akafield_dimensionless_position);
      if (_segment1_dimensionless_position_error > _error)
        _error = _segment1_dimensionless_position_error;
      
      _attempted_steps++;
      
      if (_error < _tolerance) {
        _t_local += _step;
        if (_step > _max_step)
          _max_step = _step;
        if (!_break_next && _step < _min_step)
          _min_step = _step;
        _discard = false;
      } else {
        t -= _step;
  
        if (_segment1_dimensionless_position_reset(_initial_dimensionless_position) == false) {
  
          _LOG(_WARNING_LOG_LEVEL, "WARNING: NaN present. Integration halted at t = %e.\n"
                             "         Non-finite number in integration vector \"position\" in segment 1.\n", t);
          if (_mg0_output_index_t < _mg0_output_lattice_t)
            _mg0_sample();
          
          goto _SEGMENT1_END;
        }
  
        _segment1_ip_evolve(-1);
        
        _discard = true;
        _break_next = false;
        _unsuccessful_steps++;
      }
      
      _old_step = _step;
      
      // Resize step
      if (_error < 0.5*_tolerance || _error > _tolerance) {
        const real _safetyFactor = 0.90;
        real _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-0.7/9.0)) * pow(_last_norm_error, real(0.4/9.0));
        _scalingFactor = MAX(_scalingFactor, 1.0/5.0);
        _scalingFactor = MIN(_scalingFactor, 7.0);
        if (_error > _tolerance && _scalingFactor > 1.0) {
          // If our step failed don't try and increase our step size. That would be silly.
          _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-1.0/9.0));
        }
        _old_step = _step;
        _last_norm_error = pow(_safetyFactor/_scalingFactor*pow(_last_norm_error, real(0.4/9.0)), real(9.0/0.7));
        _step *= _scalingFactor;
      }
      
    } while (_discard);
    
    if (_break_next) {
      if (_next_sample_flag[0]) {
        _mg0_sample();
        _next_sample_counter[0]++;
      }
      if (_next_sample_flag[1])
        _next_sample_flag[2] = true;
      else {
        _break_next = false;
        _t_break_next = _segment1_setup_sampling(_next_sample_flag, _next_sample_counter);
      }
    }
    
    if ( (_t_local + _step)*(1.0 + _EPSILON) > _t_break_next) {
      _break_next = true;
      _LOG(_SAMPLE_LOG_LEVEL, "Current timestep: %e\n", _old_step);
      _step = _t_break_next - _t_local;
    }
  } while (!_next_sample_flag[2]);
  
  _SEGMENT1_END:;
  xmds_free(_segment1_akafield_dimensionless_position);
  xmds_free(_segment1_akbfield_dimensionless_position);
  xmds_free(_segment1_akcfield_dimensionless_position);
  xmds_free(_segment1_akdfield_dimensionless_position);
  xmds_free(_segment1_akefield_dimensionless_position);
  xmds_free(_segment1_akffield_dimensionless_position);
  xmds_free(_segment1_akgfield_dimensionless_position);
  xmds_free(_segment1_akhfield_dimensionless_position);
  xmds_free(_segment1_akifield_dimensionless_position);
  xmds_free(_segment1_akjfield_dimensionless_position);
  xmds_free(_segment1_initial_dimensionless_position);
  
  _LOG(_SEGMENT_LOG_LEVEL, "Segment 1: minimum timestep: %e maximum timestep: %e\n", _min_step, _max_step);
  _LOG(_SEGMENT_LOG_LEVEL, "  Attempted %li steps, %.2f%% steps failed.\n", _attempted_steps, (100.0*_unsuccessful_steps)/_attempted_steps);
}


inline void _segment1_ip_evolve(int _exponent)
{
}
real _segment1_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter)
{
  // The numbers of the moment groups that need to be sampled at the next sampling point.
  // An entry of N+1 means "reached end of integration interval"
  long _momentGroupNumbersNeedingSamplingNext[2];
  long _numberOfMomentGroupsToBeSampledNext = 1;
  
  long _previous_m = 1;
  long _previous_M = 1;
  
  real _t_break_next = (real)20.0;
  _momentGroupNumbersNeedingSamplingNext[0] = 1;
  
  // initialise all flags to false
  for (long _i0 = 0; _i0 < 2; _i0++)
    _next_sample_flag[_i0] = false;
  
  /* Check if moment group needs sampling at the same time as another already discovered sample (or the final time).
   * If so, add this moment group to the to-be-sampled list. If moment group demands sampling earlier than all
   * previously noted moment groups, erase all previous ones from list and set the sample time to this earlier one.
   */
  if (_next_sample_counter[0] * _previous_M == _previous_m * 5000) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 0;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[0] * _previous_M < _previous_m * 5000) {
    _t_break_next = _next_sample_counter[0] * ((real)20.0) / ((real)5000);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 0;
    _previous_M = 5000;
    _previous_m = _next_sample_counter[0];
  }
  
  // _momentGroupNumbersNeedingSamplingNext now contains the complete list of moment groups that need
  // to be sampled at the next sampling point. Set their flags to true.
  for (long _i0 = 0; _i0 < _numberOfMomentGroupsToBeSampledNext; _i0++)
    _next_sample_flag[_momentGroupNumbersNeedingSamplingNext[_i0]] = true;
  
  return _t_break_next;
}

real _segment1_dimensionless_position_timestep_error(real* _checkfield)
{
  real _error = 1e-24;
  real _temp_error = 0.0;
  real _temp_mod = 0.0;

  
  
  {
    long _dimensionless_position_index_pointer = 0;
    #define x _active_dimensionless_position[_dimensionless_position_index_pointer + 0]
    #define y _active_dimensionless_position[_dimensionless_position_index_pointer + 1]
    #define z _active_dimensionless_position[_dimensionless_position_index_pointer + 2]
    for (long _i0 = 0; _i0 < (1); _i0++) {
      for (long  _i1 = 0; _i1 < _dimensionless_position_ncomponents; _i1++) {
        _temp_error = abs(_dimensionless_position[_dimensionless_position_index_pointer + _i1] - _checkfield[_dimensionless_position_index_pointer + _i1]) / (0.5*abs(_dimensionless_position[_dimensionless_position_index_pointer + _i1]) + 0.5*abs(_checkfield[_dimensionless_position_index_pointer + _i1]));
        
        if (_xmds_isnonfinite(_temp_error)) {
          /* For _temp_error to be NaN, both the absolute value of the higher and lower order solutions
             must BOTH be zero. This therefore implies that their difference is zero, and that there is no error. */
          _temp_error = 0.0;
        }
        
        if (_error < _temp_error) // UNVECTORISABLE
          _error = _temp_error;
      }
    
      _dimensionless_position_index_pointer += _dimensionless_position_ncomponents;
    }
    #undef x
    #undef y
    #undef z
  }
  
  return _error;
}

bool _segment1_dimensionless_position_reset(real* _reset_to_dimensionless_position)
{
  memcpy(_dimensionless_position, _reset_to_dimensionless_position, sizeof(real) * _dimensionless_position_alloc_size);
  
  /* return false if there's a NaN somewhere in the vector, otherwise return true */
  bool bNoNaNsPresent = true;
  {
    long _dimensionless_position_index_pointer = 0;
    #define x _active_dimensionless_position[_dimensionless_position_index_pointer + 0]
    #define y _active_dimensionless_position[_dimensionless_position_index_pointer + 1]
    #define z _active_dimensionless_position[_dimensionless_position_index_pointer + 2]
    for (long _i0 = 0; _i0 < (1); _i0++) {
        for (long _i1 = 0; _i1 < _dimensionless_position_ncomponents; _i1++) {
          if (_xmds_isnonfinite(_dimensionless_position[_dimensionless_position_index_pointer + _i1])) bNoNaNsPresent = false;
        }
    
      _dimensionless_position_index_pointer += _dimensionless_position_ncomponents;
    }
    #undef x
    #undef y
    #undef z
  }
  return bNoNaNsPresent;
}

// Delta A propagation operator for field dimensionless
void _segment1_dimensionless_operators_evaluate_operator0(real _step)
{
  long _dimensionless_position_index_pointer = 0;
  #define x _active_dimensionless_position[_dimensionless_position_index_pointer + 0]
  #define y _active_dimensionless_position[_dimensionless_position_index_pointer + 1]
  #define z _active_dimensionless_position[_dimensionless_position_index_pointer + 2]
  real dz_dt;
  real dy_dt;
  real dx_dt;
  
  #define dt _step
  
  // ************* Propagation code ***************
  #line 54 "lorenz.xmds"
  
  dx_dt = sigma*(y-x);
  dy_dt = r*x - y - x*z;
  dz_dt = x*y - b*z;
  
  #line 1288 "lorenz.cc"
  // **********************************************
  
  #undef dt
  
  
  _active_dimensionless_position[_dimensionless_position_index_pointer + 2] = dz_dt * _step;
  _active_dimensionless_position[_dimensionless_position_index_pointer + 1] = dy_dt * _step;
  _active_dimensionless_position[_dimensionless_position_index_pointer + 0] = dx_dt * _step;
  #undef x
  #undef y
  #undef z
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for lorenz\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("lorenz" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("lorenz" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}


FILE* _open_xsil_file(const char* _filename)
{
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "  <name>lorenz</name>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- While not strictly necessary, the following two tags are handy. -->\n");
  fprintf(fp, "  <author>Graham Dennis</author>\n");
  fprintf(fp, "  <description>\n");
  fprintf(fp, "    The Lorenz Attractor, an example of chaos.\n");
  fprintf(fp, "  </description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!--\n");
  fprintf(fp, "  This element defines some constants.  It can be used for other\n");
  fprintf(fp, "  features as well, but we will go into that in more detail later.\n");
  fprintf(fp, "  -->\n");
  fprintf(fp, "  <features>\n");
  fprintf(fp, "    <globals>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "        real sigma = 10.0;\n");
  fprintf(fp, "        real b = 8.0/3.0;\n");
  fprintf(fp, "        real r = 28.0;\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "     </globals>\n");
  fprintf(fp, "   </features>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!--\n");
  fprintf(fp, "  This part defines all of the dimensions used in the problem,\n");
  fprintf(fp, "  in this case, only the dimension of 'time' is needed.\n");
  fprintf(fp, "  -->\n");
  fprintf(fp, "  <geometry>\n");
  fprintf(fp, "    <propagation_dimension> t </propagation_dimension>\n");
  fprintf(fp, "  </geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- A 'vector' describes the variables that we will be evolving. -->\n");
  fprintf(fp, "  <vector name=\"position\" type=\"real\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      x y z\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "      x = y = z = 1.0;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <sequence>\n");
  fprintf(fp, "    <!--\n");
  fprintf(fp, "    Here we define what differential equations need to be solved\n");
  fprintf(fp, "    and what algorithm we want to use.\n");
  fprintf(fp, "    -->\n");
  fprintf(fp, "    <integrate algorithm=\"ARK89\" interval=\"20.0\" tolerance=\"1e-7\">\n");
  fprintf(fp, "      <samples>5000</samples>\n");
  fprintf(fp, "      <operators>\n");
  fprintf(fp, "        <integration_vectors>position</integration_vectors>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "        dx_dt = sigma*(y-x);\n");
  fprintf(fp, "        dy_dt = r*x - y - x*z;\n");
  fprintf(fp, "        dz_dt = x*y - b*z;\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </operators>\n");
  fprintf(fp, "    </integrate>\n");
  fprintf(fp, "  </sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <!-- This part defines what data will be saved in the output file -->\n");
  fprintf(fp, "  <output filename=\"lorenz.xsil\" format=\"hdf5\">\n");
  fprintf(fp, "    <sampling_group initial_sample=\"yes\">\n");
  fprintf(fp, "      <moments>xR yR zR</moments>\n");
  fprintf(fp, "      <dependencies>position</dependencies>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "        xR = x;\n");
  fprintf(fp, "        yR = y;\n");
  fprintf(fp, "        zR = z;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </sampling_group>\n");
  fprintf(fp, "  </output>\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 2.2.3 \"It came from the deep\" (r2989)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  long _mg0_output_raw_index_pointer = 0;
  #define xR _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define yR _active_mg0_output_raw[_mg0_output_raw_index_pointer + 1]
  #define zR _active_mg0_output_raw[_mg0_output_raw_index_pointer + 2]
  long _dimensionless_position_index_pointer = 0;
  #define x _active_dimensionless_position[_dimensionless_position_index_pointer + 0]
  #define y _active_dimensionless_position[_dimensionless_position_index_pointer + 1]
  #define z _active_dimensionless_position[_dimensionless_position_index_pointer + 2]
  // Set index pointers explicitly for (some) vectors
  _mg0_output_raw_index_pointer = ( 0
     + _mg0_output_index_t  * 1 ) * _mg0_output_raw_ncomponents;
  #define _SAMPLE_COMPLEX(variable) \
            variable ## R = variable.Re(); variable ## I = variable.Im();
  
  // *************** Sampling code ****************
  #line 68 "lorenz.xmds"
  
  xR = x;
  yR = y;
  zR = z;
  
  #line 1473 "lorenz.cc"
  // **********************************************
  
  #undef _SAMPLE_COMPLEX
  #undef xR
  #undef yR
  #undef zR
  #undef x
  #undef y
  #undef z
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  // No post processing needs to be done
}


void _mg0_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">1</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>4</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t xR yR zR \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>4</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("lorenz" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("lorenz" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg0_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/1/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg0_output_lattice_t};
  hid_t file_dataspace = H5Screate_simple(1, file_dims, NULL);
  
  hid_t dataset_xR;
  if (!H5Lexists(hdf5_file, "/1/xR", H5P_DEFAULT))
    dataset_xR = H5Dcreate(hdf5_file, "/1/xR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_xR = H5Dopen(hdf5_file, "/1/xR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_xR, dataset_t, 0);
  #endif
  hid_t dataset_yR;
  if (!H5Lexists(hdf5_file, "/1/yR", H5P_DEFAULT))
    dataset_yR = H5Dcreate(hdf5_file, "/1/yR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_yR = H5Dopen(hdf5_file, "/1/yR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_yR, dataset_t, 0);
  #endif
  hid_t dataset_zR;
  if (!H5Lexists(hdf5_file, "/1/zR", H5P_DEFAULT))
    dataset_zR = H5Dcreate(hdf5_file, "/1/zR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_zR = H5Dopen(hdf5_file, "/1/zR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_zR, dataset_t, 0);
  #endif
  H5Dclose(dataset_t);
  
  
  if ((_mg0_output_lattice_t)) {
    /* Create the data space */
    hsize_t file_start[1] = {0};
    hsize_t mem_dims[2] = {_mg0_output_lattice_t, 1};
    hsize_t mem_start[2] = {0, 0};
    hsize_t mem_stride[2] = {1, 1};
    hsize_t mem_count[2] = {_mg0_output_lattice_t, 1};
    
    
    hid_t mem_dataspace;
    mem_dims[1] = 3;
    mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
    mem_stride[1] = 3;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[1] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_xR)
      H5Dwrite(dataset_xR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    mem_start[1] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_yR)
      H5Dwrite(dataset_yR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    mem_start[1] = 2;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_zR)
      H5Dwrite(dataset_zR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_xR);
  H5Dclose(dataset_yR);
  H5Dclose(dataset_zR);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

