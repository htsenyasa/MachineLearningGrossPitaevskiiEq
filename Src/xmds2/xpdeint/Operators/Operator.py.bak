#!/usr/bin/env python




##################################################
## DEPENDENCIES
import sys
import os
import os.path
try:
    import builtins as builtin
except ImportError:
    import __builtin__ as builtin
from os.path import getmtime, exists
import time
import types
from Cheetah.Version import MinCompatibleVersion as RequiredCheetahVersion
from Cheetah.Version import MinCompatibleVersionTuple as RequiredCheetahVersionTuple
from Cheetah.Template import Template
from Cheetah.DummyTransaction import *
from Cheetah.NameMapper import NotFound, valueForName, valueFromSearchList, valueFromFrameOrSearchList
from Cheetah.CacheRegion import CacheRegion
import Cheetah.Filters as Filters
import Cheetah.ErrorCatchers as ErrorCatchers
from xpdeint.Operators._Operator import _Operator
from xpdeint.Vectors.VectorElement import VectorElement
from xpdeint.CallOnceGuards import callOncePerInstanceGuard

##################################################
## MODULE CONSTANTS
VFFSL=valueFromFrameOrSearchList
VFSL=valueFromSearchList
VFN=valueForName
currentTime=time.time
__CHEETAH_version__ = '2.4.4'
__CHEETAH_versionTuple__ = (2, 4, 4, 'development', 0)
__CHEETAH_genTime__ = 1484975071.994494
__CHEETAH_genTimestamp__ = 'Sat Jan 21 16:04:31 2017'
__CHEETAH_src__ = '/home/mattias/xmds-2.2.3/admin/staging/xmds-2.2.3/xpdeint/Operators/Operator.tmpl'
__CHEETAH_srcLastModified__ = 'Tue Nov 20 11:51:47 2012'
__CHEETAH_docstring__ = 'Autogenerated by Cheetah: The Python-Powered Template Engine'

if __CHEETAH_versionTuple__ < RequiredCheetahVersionTuple:
    raise AssertionError(
      'This template was compiled with Cheetah version'
      ' %s. Templates compiled before version %s must be recompiled.'%(
         __CHEETAH_version__, RequiredCheetahVersion))

##################################################
## CLASSES

class Operator(_Operator):

    ##################################################
    ## CHEETAH GENERATED METHODS


    def __init__(self, *args, **KWs):

        super(Operator, self).__init__(*args, **KWs)
        if not self._CHEETAH__instanceInitialized:
            cheetahKWArgs = {}
            allowedKWs = 'searchList namespaces filter filtersLib errorCatcher'.split()
            for k,v in KWs.items():
                if k in allowedKWs: cheetahKWArgs[k] = v
            self._initCheetahInstance(**cheetahKWArgs)
        

    def insideEvaluateOperatorLoops(self, **KWS):



        ## CHEETAH: generated from @def insideEvaluateOperatorLoops at line 27, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        #  Content must be provided by a subclass
        assert 0
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    @callOncePerInstanceGuard
    def initialise(self, **KWS):



        ## CHEETAH: generated from @def initialise at line 35, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = super(Operator, self).initialise()
        if _v is not None: write(_filter(_v))
        # 
        if VFFSL(SL,"operatorVector",True): # generated from line 39, col 3
            write(u'''_''')
            _v = VFFSL(SL,"parent.id",True) # u'${parent.id}' on line 40, col 2
            if _v is not None: write(_filter(_v, rawExpr=u'${parent.id}')) # from line 40, col 2.
            write(u'''_calculate_''')
            _v = VFFSL(SL,"name",True) # u'${name}' on line 40, col 25
            if _v is not None: write(_filter(_v, rawExpr=u'${name}')) # from line 40, col 25.
            write(u'''_field();
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def calculateOperatorFieldFunctionContents(self, function, **KWS):



        ## CHEETAH: generated from @def calculateOperatorFieldFunctionContents($function) at line 45, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = VFN(VFFSL(SL,"codeBlocks",True)['operatorDefinition'],"loop",False)(self.insideCalculateOperatorFieldLoops) # u"${codeBlocks['operatorDefinition'].loop(self.insideCalculateOperatorFieldLoops)}" on line 47, col 1
        if _v is not None: write(_filter(_v, rawExpr=u"${codeBlocks['operatorDefinition'].loop(self.insideCalculateOperatorFieldLoops)}")) # from line 47, col 1.
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def insideCalculateOperatorFieldLoopsBegin(self, **KWS):



        ## CHEETAH: generated from @def insideCalculateOperatorFieldLoopsBegin at line 51, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        for operatorComponentName in VFN(VFFSL(SL,"operatorComponents",True),"iterkeys",False)(): # generated from line 53, col 3
            if VFFSL(SL,"operatorVector",True) and operatorComponentName in VFFSL(SL,"operatorVector.components",True): # generated from line 54, col 5
                continue
            _v = VFFSL(SL,"operatorVector.type",True) # u'${operatorVector.type}' on line 57, col 1
            if _v is not None: write(_filter(_v, rawExpr=u'${operatorVector.type}')) # from line 57, col 1.
            write(u''' ''')
            _v = VFFSL(SL,"operatorComponentName",True) # u'$operatorComponentName' on line 57, col 24
            if _v is not None: write(_filter(_v, rawExpr=u'$operatorComponentName')) # from line 57, col 24.
            write(u''';
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def evaluateOperatorFunctionContents(self, function, **KWS):



        ## CHEETAH: generated from @def evaluateOperatorFunctionContents($function) at line 64, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        if not 'calculateOperatorField' in VFFSL(SL,"functions",True): # generated from line 66, col 3
            _v = VFFSL(SL,"evaluateOperatorFunctionContentsWithCodeBlock",False)(function) # u'${evaluateOperatorFunctionContentsWithCodeBlock(function)}' on line 67, col 1
            if _v is not None: write(_filter(_v, rawExpr=u'${evaluateOperatorFunctionContentsWithCodeBlock(function)}')) # from line 67, col 1.
        else: # generated from line 68, col 3
            _v = VFFSL(SL,"evaluateOperatorFunctionContentsWithoutCodeBlock",False)(function) # u'${evaluateOperatorFunctionContentsWithoutCodeBlock(function)}' on line 69, col 1
            if _v is not None: write(_filter(_v, rawExpr=u'${evaluateOperatorFunctionContentsWithoutCodeBlock(function)}')) # from line 69, col 1.
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def evaluateOperatorFunctionContentsWithCodeBlock(self, function, **KWS):



        ## CHEETAH: generated from @def evaluateOperatorFunctionContentsWithCodeBlock($function) at line 74, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = VFFSL(SL,"callEvaluateLoop",True) # u'${callEvaluateLoop}' on line 76, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${callEvaluateLoop}')) # from line 76, col 1.
        # 
        if VFFSL(SL,"resultVector",True) and VFFSL(SL,"resultVector.needsTransforms",True): # generated from line 78, col 3
            write(u'''
_''')
            _v = VFFSL(SL,"resultVector.id",True) # u'${resultVector.id}' on line 80, col 2
            if _v is not None: write(_filter(_v, rawExpr=u'${resultVector.id}')) # from line 80, col 2.
            write(u'''_basis = ''')
            _v = VFFSL(SL,"basisIndexForBasis",False)(VFFSL(SL,"operatorBasis",True)) # u'$basisIndexForBasis($operatorBasis)' on line 80, col 29
            if _v is not None: write(_filter(_v, rawExpr=u'$basisIndexForBasis($operatorBasis)')) # from line 80, col 29.
            write(u''';
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def callEvaluateLoop(self, **KWS):



        ## CHEETAH: generated from @def callEvaluateLoop at line 85, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        _v = VFN(VFFSL(SL,"codeBlocks",True)['operatorDefinition'],"loop",False)(self.insideEvaluateOperatorLoops) # u"${codeBlocks['operatorDefinition'].loop(self.insideEvaluateOperatorLoops)}" on line 86, col 1
        if _v is not None: write(_filter(_v, rawExpr=u"${codeBlocks['operatorDefinition'].loop(self.insideEvaluateOperatorLoops)}")) # from line 86, col 1.
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def insideEvaluateOperatorLoopsBegin(self, **KWS):



        ## CHEETAH: generated from @def insideEvaluateOperatorLoopsBegin at line 89, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        if not VFFSL(SL,"operatorVector",True): # generated from line 91, col 3
            #  If we don't have an operator vector, then we need to create
            #  the component variables so that the user can set them inside
            #  the loop
            for operatorComponentName, operatorComponentDictionary in VFN(VFFSL(SL,"operatorComponents",True),"iteritems",False)(): # generated from line 95, col 5
                typeNamesSet = set([vector.type for vector in operatorComponentDictionary.iterkeys()])
                typeName = 'real'
                if 'complex' in typeNamesSet: # generated from line 98, col 7
                    typeName = 'complex'
                _v = VFFSL(SL,"typeName",True) # u'${typeName}' on line 101, col 1
                if _v is not None: write(_filter(_v, rawExpr=u'${typeName}')) # from line 101, col 1.
                write(u''' ''')
                _v = VFFSL(SL,"operatorComponentName",True) # u'${operatorComponentName}' on line 101, col 13
                if _v is not None: write(_filter(_v, rawExpr=u'${operatorComponentName}')) # from line 101, col 13.
                write(u''';
''')
            write(u'''
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def evaluateOperatorFunctionContentsWithoutCodeBlock(self, function, **KWS):



        ## CHEETAH: generated from @def evaluateOperatorFunctionContentsWithoutCodeBlock($function) at line 108, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        #  We need to loop over all of the vectors to which we are applying our operators.
        # 
        _v = VFFSL(SL,"transformVectorsToBasis",False)(VFFSL(SL,"targetVectors",True), VFFSL(SL,"operatorBasis",True)) # u'${transformVectorsToBasis($targetVectors, $operatorBasis)}' on line 112, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${transformVectorsToBasis($targetVectors, $operatorBasis)}')) # from line 112, col 1.
        # 
        write(u'''
''')
        #  We have an operator vector and we will need to loop over it
        setOfVectorsToLoopOver = VFN(VFFSL(SL,"targetVectors",True),"copy",False)()
        VFN(VFFSL(SL,"setOfVectorsToLoopOver",True),"add",False)(VFFSL(SL,"operatorVector",True))
        if VFFSL(SL,"resultVector",True): # generated from line 118, col 3
            VFN(VFFSL(SL,"setOfVectorsToLoopOver",True),"add",False)(VFFSL(SL,"resultVector",True))
        # 
        _v = VFFSL(SL,"evaluateOperatorLoop",False)(setOfVectorsToLoopOver) # u'${evaluateOperatorLoop(setOfVectorsToLoopOver)}' on line 122, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${evaluateOperatorLoop(setOfVectorsToLoopOver)}')) # from line 122, col 1.
        # 
        if VFFSL(SL,"resultVector",True) and VFFSL(SL,"resultVector.needsTransforms",True): # generated from line 124, col 3
            write(u'''
_''')
            _v = VFFSL(SL,"resultVector.id",True) # u'${resultVector.id}' on line 126, col 2
            if _v is not None: write(_filter(_v, rawExpr=u'${resultVector.id}')) # from line 126, col 2.
            write(u'''_basis = ''')
            _v = VFFSL(SL,"basisIndexForBasis",False)(VFFSL(SL,"operatorBasis",True)) # u'$basisIndexForBasis($operatorBasis)' on line 126, col 29
            if _v is not None: write(_filter(_v, rawExpr=u'$basisIndexForBasis($operatorBasis)')) # from line 126, col 29.
            write(u''';
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def optimisedOperatorCopyBegin(self, **KWS):



        ## CHEETAH: generated from @def optimisedOperatorCopyBegin at line 131, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        #  This optimisation only works in a restricted set of circumstances.  It's common enough, but not as general
        #  as it could be.  Basically, you need a single operator name (e.g. L, not Lx and Ly) which is applied to all
        #  components of a vector.
        if len(VFFSL(SL,"targetVectors",True)) != 1 or not VFFSL(SL,"resultVector",True) or len(VFFSL(SL,"operatorNames",True)) != 1: # generated from line 135, col 3
            return
        targetVector = VFFSL(SL,"anyObject",False)(VFFSL(SL,"targetVectors",True))
        if VFFSL(SL,"targetVector.nComponents",True) != VFFSL(SL,"resultVector.nComponents",True) or not targetVector.needsTransforms: # generated from line 139, col 3
            return
        #  For this operator, we don't modify the target vector, so if we just transform it, we'll have to transform it back again
        #  Here, we copy the target vector into the result vector because it's the same size. This way we can avoid the second transform
        write(u'''memcpy(_active_''')
        _v = VFFSL(SL,"resultVector.id",True) # u'${resultVector.id}' on line 144, col 16
        if _v is not None: write(_filter(_v, rawExpr=u'${resultVector.id}')) # from line 144, col 16.
        write(u''', _active_''')
        _v = VFFSL(SL,"targetVector.id",True) # u'${targetVector.id}' on line 144, col 44
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.id}')) # from line 144, col 44.
        write(u''', ''')
        _v = VFFSL(SL,"targetVector.allocSize",True) # u'${targetVector.allocSize}' on line 144, col 64
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.allocSize}')) # from line 144, col 64.
        write(u''' * sizeof(''')
        _v = VFFSL(SL,"targetVector.type",True) # u'${targetVector.type}' on line 144, col 99
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.type}')) # from line 144, col 99.
        write(u'''));
''')
        _v = VFFSL(SL,"targetVector.type",True) # u'${targetVector.type}' on line 145, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.type}')) # from line 145, col 1.
        write(u''' *__backup_ptr = _active_''')
        _v = VFFSL(SL,"targetVector.id",True) # u'${targetVector.id}' on line 145, col 46
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.id}')) # from line 145, col 46.
        write(u''';
ptrdiff_t __backup_basis = _''')
        _v = VFFSL(SL,"targetVector.id",True) # u'${targetVector.id}' on line 146, col 29
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.id}')) # from line 146, col 29.
        write(u'''_basis;
_active_''')
        _v = VFFSL(SL,"targetVector.id",True) # u'${targetVector.id}' on line 147, col 9
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.id}')) # from line 147, col 9.
        write(u''' = _active_''')
        _v = VFFSL(SL,"resultVector.id",True) # u'${resultVector.id}' on line 147, col 38
        if _v is not None: write(_filter(_v, rawExpr=u'${resultVector.id}')) # from line 147, col 38.
        write(u''';

''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def optimisedOperatorCopyEnd(self, **KWS):



        ## CHEETAH: generated from @def optimisedOperatorCopyEnd at line 152, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        if len(VFFSL(SL,"targetVectors",True)) != 1 or not VFFSL(SL,"resultVector",True) or len(VFFSL(SL,"operatorNames",True)) != 1: # generated from line 153, col 3
            return
        targetVector = VFFSL(SL,"anyObject",False)(VFFSL(SL,"targetVectors",True))
        if VFFSL(SL,"targetVector.nComponents",True) != VFFSL(SL,"resultVector.nComponents",True) or not targetVector.needsTransforms: # generated from line 157, col 3
            return
        write(u'''_active_''')
        _v = VFFSL(SL,"targetVector.id",True) # u'${targetVector.id}' on line 160, col 9
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.id}')) # from line 160, col 9.
        write(u''' = __backup_ptr;
_''')
        _v = VFFSL(SL,"targetVector.id",True) # u'${targetVector.id}' on line 161, col 2
        if _v is not None: write(_filter(_v, rawExpr=u'${targetVector.id}')) # from line 161, col 2.
        write(u'''_basis = __backup_basis;
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def writeBody(self, **KWS):



        ## CHEETAH: main method generated for this template
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        # Operator.tmpl
        # 
        # Created by Graham Dennis on 2007-10-13.
        # 
        # Copyright (c) 2007-2012, Graham Dennis
        # 
        # This program is free software: you can redistribute it and/or modify
        # it under the terms of the GNU General Public License as published by
        # the Free Software Foundation, either version 2 of the License, or
        # (at your option) any later version.
        # 
        # This program is distributed in the hope that it will be useful,
        # but WITHOUT ANY WARRANTY; without even the implied warranty of
        # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        # GNU General Public License for more details.
        # 
        # You should have received a copy of the GNU General Public License
        # along with this program.  If not, see <http://www.gnu.org/licenses/>.
        # 
        write(u'''













''')
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        
    ##################################################
    ## CHEETAH GENERATED ATTRIBUTES


    _CHEETAH__instanceInitialized = False

    _CHEETAH_version = __CHEETAH_version__

    _CHEETAH_versionTuple = __CHEETAH_versionTuple__

    _CHEETAH_genTime = __CHEETAH_genTime__

    _CHEETAH_genTimestamp = __CHEETAH_genTimestamp__

    _CHEETAH_src = __CHEETAH_src__

    _CHEETAH_srcLastModified = __CHEETAH_srcLastModified__

    evaluateOperatorFunctionArgument = 'real _step'

    _mainCheetahMethod_for_Operator= 'writeBody'

## END CLASS DEFINITION

if not hasattr(Operator, '_initCheetahAttributes'):
    templateAPIClass = getattr(Operator, '_CHEETAH_templateClass', Template)
    templateAPIClass._addCheetahPlumbingCodeToClass(Operator)


# CHEETAH was developed by Tavis Rudd and Mike Orr
# with code, advice and input from many other volunteers.
# For more information visit http://www.CheetahTemplate.org/

##################################################
## if run from command line:
if __name__ == '__main__':
    from Cheetah.TemplateCmdLineIface import CmdLineIface
    CmdLineIface(templateObj=Operator()).run()


