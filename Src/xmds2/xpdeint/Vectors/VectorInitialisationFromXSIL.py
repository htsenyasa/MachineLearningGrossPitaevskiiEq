#!/usr/bin/env python




##################################################
## DEPENDENCIES
import sys
import os
import os.path
try:
    import builtins as builtin
except ImportError:
    import builtins as builtin
from os.path import getmtime, exists
import time
import types
from Cheetah.Version import MinCompatibleVersion as RequiredCheetahVersion
from Cheetah.Version import MinCompatibleVersionTuple as RequiredCheetahVersionTuple
from Cheetah.Template import Template
from Cheetah.DummyTransaction import *
from Cheetah.NameMapper import NotFound, valueForName, valueFromSearchList, valueFromFrameOrSearchList
from Cheetah.CacheRegion import CacheRegion
import Cheetah.Filters as Filters
import Cheetah.ErrorCatchers as ErrorCatchers
from xpdeint.Vectors.VectorInitialisation import VectorInitialisation
from xpdeint.CallOnceGuards import callOnceGuard
from xpdeint.Geometry.UniformDimensionRepresentation import UniformDimensionRepresentation
from xpdeint.Geometry.SplitUniformDimensionRepresentation import SplitUniformDimensionRepresentation

##################################################
## MODULE CONSTANTS
VFFSL=valueFromFrameOrSearchList
VFSL=valueFromSearchList
VFN=valueForName
currentTime=time.time
__CHEETAH_version__ = '2.4.4'
__CHEETAH_versionTuple__ = (2, 4, 4, 'development', 0)
__CHEETAH_genTime__ = 1484975073.065966
__CHEETAH_genTimestamp__ = 'Sat Jan 21 16:04:33 2017'
__CHEETAH_src__ = '/home/mattias/xmds-2.2.3/admin/staging/xmds-2.2.3/xpdeint/Vectors/VectorInitialisationFromXSIL.tmpl'
__CHEETAH_srcLastModified__ = 'Sat Jan  7 13:14:51 2017'
__CHEETAH_docstring__ = 'Autogenerated by Cheetah: The Python-Powered Template Engine'

if __CHEETAH_versionTuple__ < RequiredCheetahVersionTuple:
    raise AssertionError(
      'This template was compiled with Cheetah version'
      ' %s. Templates compiled before version %s must be recompiled.'%(
         __CHEETAH_version__, RequiredCheetahVersion))

##################################################
## CLASSES

class VectorInitialisationFromXSIL(VectorInitialisation):

    ##################################################
    ## CHEETAH GENERATED METHODS


    def __init__(self, *args, **KWs):

        super(VectorInitialisationFromXSIL, self).__init__(*args, **KWs)
        if not self._CHEETAH__instanceInitialized:
            cheetahKWArgs = {}
            allowedKWs = 'searchList namespaces filter filtersLib errorCatcher'.split()
            for k,v in list(KWs.items()):
                if k in allowedKWs: cheetahKWArgs[k] = v
            self._initCheetahInstance(**cheetahKWArgs)
        

    def description(self, **KWS):



        ## Generated from @def description: Vector initialisation from an XSIL file at line 30, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        write('''Vector initialisation from an XSIL file''')
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    @callOnceGuard
    def static_functionPrototypes(self, **KWS):



        ## CHEETAH: generated from @def static_functionPrototypes at line 33, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = super(VectorInitialisationFromXSIL, self).static_functionPrototypes()
        if _v is not None: write(_filter(_v))
        # 
        write('''static inline uint32_t XMDSSwapInt32(uint32_t __arg);
static inline uint64_t XMDSSwapInt64(uint64_t __arg);
static inline float XMDSSwapFloat(float __in);
static inline double XMDSSwapDouble(double __in);
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    @callOnceGuard
    def globals(self, **KWS):



        ## CHEETAH: generated from @def globals at line 45, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        _v = super(VectorInitialisationFromXSIL, self).globals()
        if _v is not None: write(_filter(_v))
        # 
        write('''// This stuff is here because libxmds requires it.
// That is because we need the XML parser in order to be able
// to load XSIL files to initialise fields
bool debugFlag = false;
bool xmlDebugFlag =  false;
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    @callOnceGuard
    def static_functionImplementations(self, **KWS):



        ## CHEETAH: generated from @def static_functionImplementations at line 57, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = super(VectorInitialisationFromXSIL, self).static_functionImplementations()
        if _v is not None: write(_filter(_v))
        # 
        write('''
static inline uint32_t XMDSSwapInt32(uint32_t __arg)
{
  union {
    uint8_t ui8[4];
    uint32_t ui32;
  } a, b;
  a.ui32 = __arg;
  b.ui8[0] = a.ui8[3];
  b.ui8[1] = a.ui8[2];
  b.ui8[2] = a.ui8[1];
  b.ui8[3] = a.ui8[0];
  return b.ui32;
}

static inline uint64_t XMDSSwapInt64(uint64_t __arg)
{
  union {
    uint32_t ui32[2];
    uint64_t ui64;
  } a, b;
  a.ui64 = __arg;
  b.ui32[0] = XMDSSwapInt32(a.ui32[1]);
  b.ui32[1] = XMDSSwapInt32(a.ui32[0]);
  return b.ui64;
}

static inline float XMDSSwapFloat(float __arg)
{
  union {
    uint32_t ui32;
    float f;
  } a;
  a.f = __arg;
  a.ui32 = XMDSSwapInt32(a.ui32);
  return a.f;
}

static inline double XMDSSwapDouble(double __arg)
{
  union {
    uint64_t ui64;
    double d;
  } a;
  a.d = __arg;
  a.ui64 = XMDSSwapInt64(a.ui64);
  return a.d;
}
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def initialiseVector(self, **KWS):



        ## CHEETAH: generated from @def initialiseVector at line 116, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        initialisationCodeBlock = VFFSL(SL,"codeBlocks",True)['initialisation']
        write('''// XSIL initialisation has three stages.
// 1. Initialise the vector to zero.
// 2. Execute any CDATA code if there is any.
// 3. Read data from the XSIL file.

{
  // Stage 1 of initialisation
  bzero(_active_''')
        _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 126, col 17
        if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 126, col 17.
        write(''', sizeof(''')
        _v = VFFSL(SL,"vector.type",True) # u'${vector.type}' on line 126, col 38
        if _v is not None: write(_filter(_v, rawExpr='${vector.type}')) # from line 126, col 38.
        write(''') * ''')
        _v = VFFSL(SL,"vector.allocSize",True) # u'${vector.allocSize}' on line 126, col 56
        if _v is not None: write(_filter(_v, rawExpr='${vector.allocSize}')) # from line 126, col 56.
        write(''');
''')
        if VFN(VFFSL(SL,"initialisationCodeBlock.codeString",True),"isspace",False)(): # generated from line 127, col 3
            write('''  // There is no stage 2
''')
        else: # generated from line 129, col 3
            vectorOverrides = []
            if VFFSL(SL,"vector.integratingComponents",True): # generated from line 131, col 5
                vectorOverrides.append(VFFSL(SL,"vector",True))
            write('''  // Stage 2 of initialisation
  ''')
            _v = VFN(VFFSL(SL,"initialisationCodeBlock",True),"loop",False)(self.insideInitialisationLoops, vectorOverrides=vectorOverrides) # u'${initialisationCodeBlock.loop(self.insideInitialisationLoops, vectorOverrides=vectorOverrides), autoIndent=True}' on line 135, col 3
            if _v is not None: write(_filter(_v, autoIndent=True, rawExpr='${initialisationCodeBlock.loop(self.insideInitialisationLoops, vectorOverrides=vectorOverrides), autoIndent=True}')) # from line 135, col 3.
        write('''}

const char **_dimNames  = new const char* [_''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 139, col 45
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 139, col 45.
        write('''_ndims];
double *_dimDelta = new double[_''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 140, col 33
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 140, col 33.
        write('''_ndims];
double *_dimMin   = new double[_''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 141, col 33
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 141, col 33.
        write('''_ndims];
unsigned long *_dimLattice = new unsigned long[_''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 142, col 49
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 142, col 49.
        write('''_ndims];

''')
        for dimensionNumber, dimension in enumerate(VFFSL(SL,"vector.field.dimensions",True)): # generated from line 144, col 3
            dimRep = dimension.inBasis(VFFSL(SL,"vector.initialBasis",True))
            write('''_dimNames[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'$dimensionNumber' on line 146, col 11
            if _v is not None: write(_filter(_v, rawExpr='$dimensionNumber')) # from line 146, col 11.
            write(''']   = "''')
            _v = VFFSL(SL,"dimRep.name",True) # u'${dimRep.name}' on line 146, col 34
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.name}')) # from line 146, col 34.
            write('''";
_dimDelta[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'$dimensionNumber' on line 147, col 11
            if _v is not None: write(_filter(_v, rawExpr='$dimensionNumber')) # from line 147, col 11.
            write(''']   = ''')
            _v = VFFSL(SL,"dimRep.stepSize",True) # u'${dimRep.stepSize}' on line 147, col 33
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.stepSize}')) # from line 147, col 33.
            write(''';
_dimMin[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'$dimensionNumber' on line 148, col 9
            if _v is not None: write(_filter(_v, rawExpr='$dimensionNumber')) # from line 148, col 9.
            write(''']     = ''')
            _v = VFFSL(SL,"dimRep.minimum",True) # u'${dimRep.minimum}' on line 148, col 33
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.minimum}')) # from line 148, col 33.
            write(''';
_dimLattice[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'$dimensionNumber' on line 149, col 13
            if _v is not None: write(_filter(_v, rawExpr='$dimensionNumber')) # from line 149, col 13.
            write('''] = ''')
            _v = VFFSL(SL,"dimRep.globalLattice",True) # u'${dimRep.globalLattice}' on line 149, col 33
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.globalLattice}')) # from line 149, col 33.
            write(''';

''')
        # 
        componentNameSizePrefix = ''
        if VFFSL(SL,"vector.type",True) == 'complex': # generated from line 154, col 3
            componentNameSizePrefix = '2 * '
        write('''const char **_componentNames = new const char*[''')
        _v = VFFSL(SL,"componentNameSizePrefix",True) # u'${componentNameSizePrefix}' on line 157, col 48
        if _v is not None: write(_filter(_v, rawExpr='${componentNameSizePrefix}')) # from line 157, col 48.
        write('''_''')
        _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 157, col 75
        if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 157, col 75.
        write('''_ncomponents + 1];
int *_componentFieldIndices = new int[''')
        _v = VFFSL(SL,"componentNameSizePrefix",True) # u'${componentNameSizePrefix}' on line 158, col 39
        if _v is not None: write(_filter(_v, rawExpr='${componentNameSizePrefix}')) # from line 158, col 39.
        write('''_''')
        _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 158, col 66
        if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 158, col 66.
        write('''_ncomponents];

''')
        componentNameIndex = 0
        for component in VFFSL(SL,"vector.components",True): # generated from line 161, col 3
            write('''_componentNames[''')
            _v = VFFSL(SL,"componentNameIndex",True) # u'$componentNameIndex' on line 162, col 17
            if _v is not None: write(_filter(_v, rawExpr='$componentNameIndex')) # from line 162, col 17.
            write('''] = "''')
            _v = VFFSL(SL,"component",True) # u'${component}' on line 162, col 41
            if _v is not None: write(_filter(_v, rawExpr='${component}')) # from line 162, col 41.
            write('''R";
''')
            componentNameIndex += 1
            # 
            if VFFSL(SL,"vector.type",True) == 'complex': # generated from line 165, col 5
                write('''_componentNames[''')
                _v = VFFSL(SL,"componentNameIndex",True) # u'$componentNameIndex' on line 166, col 17
                if _v is not None: write(_filter(_v, rawExpr='$componentNameIndex')) # from line 166, col 17.
                write('''] = "''')
                _v = VFFSL(SL,"component",True) # u'${component}' on line 166, col 41
                if _v is not None: write(_filter(_v, rawExpr='${component}')) # from line 166, col 41.
                write('''I";
''')
                componentNameIndex += 1
            write('''
''')
        write('''_componentNames[''')
        _v = VFFSL(SL,"componentNameIndex",True) # u'$componentNameIndex' on line 171, col 17
        if _v is not None: write(_filter(_v, rawExpr='$componentNameIndex')) # from line 171, col 17.
        write('''] = NULL;

char *_binaryDataFilename;
int _unsignedLongSize;
bool _dataEncodingIsNative;
bool _isPrecisionDouble;
unsigned long _nDataComponents;
unsigned long *_inputLattice;
int *_componentInputIndices;

if (!initialiseFieldFromXSILFile("''')
        _v = VFFSL(SL,"filename",True) # u'${filename}' on line 181, col 35
        if _v is not None: write(_filter(_v, rawExpr='${filename}')) # from line 181, col 35.
        write('''", "''')
        _v = VFFSL(SL,"momentGroupName",True) # u'${momentGroupName}' on line 181, col 50
        if _v is not None: write(_filter(_v, rawExpr='${momentGroupName}')) # from line 181, col 50.
        write('''", _''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 181, col 72
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 181, col 72.
        write('''_ndims, _dimNames, _componentNames, 
                                 // output variables
                                 &_binaryDataFilename, &_unsignedLongSize, &_dataEncodingIsNative, &_isPrecisionDouble,
                                 &_nDataComponents, &_inputLattice, &_componentInputIndices))
  _LOG(_ERROR_LOG_LEVEL, "Unable to load data from ''')
        _v = VFFSL(SL,"filename",True) # u'${filename}' on line 185, col 52
        if _v is not None: write(_filter(_v, rawExpr='${filename}')) # from line 185, col 52.
        write('''\\nExiting.\\n");

FILE *_inputFile = fopen(_binaryDataFilename, "rb");
if (_inputFile == NULL)
  _LOG(_ERROR_LOG_LEVEL, "Unable to open binary input file %s\\n", _binaryDataFilename);

typedef union {
  float *_floatPtr;
  double *_doublePtr;
} _GenericRealNumberPtr;

typedef union {
  unsigned long _ulong;
  uint32_t _uint32;
  uint64_t _uint64;
} _GenericUnsignedLong;

_GenericUnsignedLong _size;
_GenericRealNumberPtr *_inputData = new _GenericRealNumberPtr[_''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 203, col 64
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 203, col 64.
        write('''_ndims];

// loop over the dimensions in the binary file
for (int __i = 0; __i < _''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 206, col 26
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 206, col 26.
        write('''_ndims; __i++) {
  uint64_t _sizeValue;
  switch(_unsignedLongSize) {
''')
        for unsignedLongSize, unionElement, typeName, swapFunctionName in [('0', '_ulong',  'unsigned long', 'XMDSSwapInt32'),                                                                      ('4', '_uint32', 'uint32_t',      'XMDSSwapInt32'),                                                                      ('8', '_uint64', 'uint64_t',      'XMDSSwapInt64')]: # generated from line 209, col 3
            write('''    case ''')
            _v = VFFSL(SL,"unsignedLongSize",True) # u'${unsignedLongSize}' on line 212, col 10
            if _v is not None: write(_filter(_v, rawExpr='${unsignedLongSize}')) # from line 212, col 10.
            write(''':
      fread(&_size.''')
            _v = VFFSL(SL,"unionElement",True) # u'${unionElement}' on line 213, col 20
            if _v is not None: write(_filter(_v, rawExpr='${unionElement}')) # from line 213, col 20.
            write(''', sizeof(''')
            _v = VFFSL(SL,"typeName",True) # u'${typeName}' on line 213, col 44
            if _v is not None: write(_filter(_v, rawExpr='${typeName}')) # from line 213, col 44.
            write('''), 1, _inputFile);
      if (_dataEncodingIsNative)
        _sizeValue = _size.''')
            _v = VFFSL(SL,"unionElement",True) # u'${unionElement}' on line 215, col 28
            if _v is not None: write(_filter(_v, rawExpr='${unionElement}')) # from line 215, col 28.
            write(''';
      else
        _sizeValue = ''')
            _v = VFFSL(SL,"swapFunctionName",True) # u'${swapFunctionName}' on line 217, col 22
            if _v is not None: write(_filter(_v, rawExpr='${swapFunctionName}')) # from line 217, col 22.
            write('''(_size.''')
            _v = VFFSL(SL,"unionElement",True) # u'${unionElement}' on line 217, col 48
            if _v is not None: write(_filter(_v, rawExpr='${unionElement}')) # from line 217, col 48.
            write(''');
      _unsignedLongSize = sizeof(''')
            _v = VFFSL(SL,"typeName",True) # u'${typeName}' on line 218, col 34
            if _v is not None: write(_filter(_v, rawExpr='${typeName}')) # from line 218, col 34.
            write(''');
      break;
    
''')
        write('''    default:
      _LOG(_ERROR_LOG_LEVEL, "Unexpected unsigned long size in input XSIL file. Was expecting \'4\' or \'8\', instead got \'%i\'\\n", _unsignedLongSize);
  }
  
  // Read in the data (in either single or double precision)
  if (_isPrecisionDouble) {
    _inputData[__i]._doublePtr = new double[_sizeValue];
    fread(_inputData[__i]._doublePtr, sizeof(double), _sizeValue, _inputFile);
    if (!_dataEncodingIsNative) {
      for (unsigned int __j = 0; __j < _sizeValue; __j++)
        _inputData[__i]._doublePtr[__j] = XMDSSwapDouble(_inputData[__i]._doublePtr[__j]);
    }
  } else {
    _inputData[__i]._floatPtr = new float[_sizeValue];
    fread(_inputData[__i]._floatPtr, sizeof(float), _sizeValue, _inputFile);
    if (!_dataEncodingIsNative) {
      for (unsigned int __j = 0; __j < _sizeValue; __j++)
        _inputData[__i]._floatPtr[__j] = XMDSSwapFloat(_inputData[__i]._floatPtr[__j]);
    }
  }
  
  double _difference;
  if (_isPrecisionDouble)
    _difference = _inputData[__i]._doublePtr[1] - _inputData[__i]._doublePtr[0];
  else
    _difference = _inputData[__i]._floatPtr[1]  - _inputData[__i]._floatPtr[0];
  
  // Assert that the deltas are the same to within 1%
  if (abs(_dimDelta[__i] - _difference) > 0.01 * _dimDelta[__i])
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "The step size in the \'%s\' dimension of the input data and the simulation grid do not match.\\n"
                           "The step size in the \'%s\' dimension was %e, while the input data had a step size of %e.\\n",
                           _dimNames[__i], _dimNames[__i], _dimDelta[__i], _difference);
''')
        # 
        if VFFSL(SL,"geometryMatchingMode",True) == 'strict': # generated from line 256, col 3
            write('''  
  // STRICT MODE: assert that the start point is the same to within 10% of one delta,
  //              and that the number of lattice points is the same.
  double _start;
  if (_isPrecisionDouble)
    _start = _inputData[__i]._doublePtr[0];
  else
    _start = _inputData[__i]._floatPtr[0];
  
  if (abs(_dimMin[__i] - _start) > 0.1*_dimDelta[__i])
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict, so the starting coordinate of each dimension in the field\\n"
                           "must be the same as in the input grid.\\n"
                           "The problem is with dimension \'%s\'.\\n", _dimNames[__i]);
  
  if (_dimLattice[__i] != _inputLattice[__i])
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict, so the number of lattice points in each dimension of the field\\n"
                           "must be the same as in the input grid.\\n"
                           "The problem is with dimension \'%s\'.\\n", _dimNames[__i]);
''')
        write('''}

long _binaryFileBaseOffset = ftell(_inputFile);
long _realNumberSize = _isPrecisionDouble ? sizeof(double) : sizeof(float);
off_t _vectorFieldSize = _unsignedLongSize + _realNumberSize''')
        _v = ''.join([''.join([' * _inputLattice[',str(VFFSL(SL,"i",True)),']']) for i in range(len(VFFSL(SL,"vector.field.dimensions",True)))]) # u"${''.join([c' * _inputLattice[$i]' for i in range(len($vector.field.dimensions))])}" on line 282, col 61
        if _v is not None: write(_filter(_v, rawExpr="${''.join([c' * _inputLattice[$i]' for i in range(len($vector.field.dimensions))])}")) # from line 282, col 61.
        write(''';

// Create minimum value variables for dimensions not in fourier space
''')
        for dimensionNumber, dimension in enumerate(VFFSL(SL,"vector.field.dimensions",True)): # generated from line 285, col 3
            write('''double _inputfield_min_''')
            _v = VFFSL(SL,"dimension.name",True) # u'${dimension.name}' on line 286, col 24
            if _v is not None: write(_filter(_v, rawExpr='${dimension.name}')) # from line 286, col 24.
            write(''';
if (_isPrecisionDouble)
  _inputfield_min_''')
            _v = VFFSL(SL,"dimension.name",True) # u'${dimension.name}' on line 288, col 19
            if _v is not None: write(_filter(_v, rawExpr='${dimension.name}')) # from line 288, col 19.
            write(''' = _inputData[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 288, col 50
            if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 288, col 50.
            write(''']._doublePtr[0];
else
  _inputfield_min_''')
            _v = VFFSL(SL,"dimension.name",True) # u'${dimension.name}' on line 290, col 19
            if _v is not None: write(_filter(_v, rawExpr='${dimension.name}')) # from line 290, col 19.
            write(''' = _inputData[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 290, col 50
            if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 290, col 50.
            write(''']._floatPtr[0];
''')
        write('''
''')
        if len(VFFSL(SL,"vector.field.dimensions",True)): # generated from line 293, col 3
            write('''// Create inputfield index variables
long ''')
            _v = ', '.join([''.join(['_inputfield',str(VFN(VFN(VFFSL(SL,"dim",True),"inBasis",False)(VFFSL(SL,"vector.initialBasis",True)),"loopIndex",True))]) for dim in VFFSL(SL,"vector.field.dimensions",True)]) # u"${', '.join([c'_inputfield${dim.inBasis($vector.initialBasis).loopIndex}' for dim in $vector.field.dimensions])}" on line 295, col 6
            if _v is not None: write(_filter(_v, rawExpr="${', '.join([c'_inputfield${dim.inBasis($vector.initialBasis).loopIndex}' for dim in $vector.field.dimensions])}")) # from line 295, col 6.
            write(''';
''')
        write('''
// Index pointer into the input array (new and old)
off_t _inputfield_index_pointer, _inputfield_old_index_pointer;
for (unsigned int _component = 0; _component < ''')
        _v = VFFSL(SL,"componentNameSizePrefix",True) # u'${componentNameSizePrefix}' on line 300, col 48
        if _v is not None: write(_filter(_v, rawExpr='${componentNameSizePrefix}')) # from line 300, col 48.
        write('''_''')
        _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 300, col 75
        if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 300, col 75.
        write("""_ncomponents; _component++) {
  if (_componentInputIndices[_component] == -1)
    // This just means that this component doesn't exist in the XSIL file
    continue;
  _inputfield_index_pointer = -42; // Just so that we always seek the first time
  
""")
        loopingVectors = VFN(VFFSL(SL,"initialisationCodeBlock.dependencies",True),"copy",False)()
        loopingVectors.add(VFFSL(SL,"vector",True))
        write('''  
  ''')
        _v = VFFSL(SL,"loopOverFieldInBasisWithVectorsAndInnerContent",False)(VFFSL(SL,"initialisationCodeBlock.field",True),
                                                   VFFSL(SL,"initialisationCodeBlock.basis",True),
                                                   VFFSL(SL,"loopingVectors",True),
                                                   VFFSL(SL,"insideDataLoops",True))
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr='${loopOverFieldInBasisWithVectorsAndInnerContent($initialisationCodeBlock.field,\n                                                   $initialisationCodeBlock.basis,\n                                                   $loopingVectors,\n                                                   $insideDataLoops), autoIndent=True}')) # from line 309, col 3.
        write('''  
} // end the loop over components

fclose(_inputFile);
delete [] _dimNames;
delete [] _componentNames;
free(_binaryDataFilename);
delete [] _inputLattice;
delete [] _componentInputIndices;
for (int __i = 0; __i < _''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 322, col 26
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 322, col 26.
        write('''_ndims; __i++) {
  if (_isPrecisionDouble)
    delete [] _inputData[__i]._doublePtr;
  else
    delete [] _inputData[__i]._floatPtr;
}
delete [] _inputData;
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def insideInitialisationLoops(self, codeString, **KWS):



        ## CHEETAH: generated from @def insideInitialisationLoops($codeString) at line 332, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        write("""// Stage 2 of initialisation

// The purpose of the following define is to give a (somewhat helpful) compile-time error
// if the user has attempted to use the propagation dimension variable in the initialisation
// block of a <vector> element. If they're trying to do this, what they really want is a 
// <computed_vector> instead.
#define """)
        _v = VFFSL(SL,"propagationDimension",True) # u'${propagationDimension}' on line 340, col 9
        if _v is not None: write(_filter(_v, rawExpr='${propagationDimension}')) # from line 340, col 9.
        write(''' Dont_use_propagation_dimension_''')
        _v = VFFSL(SL,"propagationDimension",True) # u'${propagationDimension}' on line 340, col 64
        if _v is not None: write(_filter(_v, rawExpr='${propagationDimension}')) # from line 340, col 64.
        write('''_in_vector_element_CDATA_block___Use_a_computed_vector_instead

// ********** Initialisation code ***************
''')
        _v = VFFSL(SL,"codeString",True) # u'${codeString}' on line 343, col 1
        if _v is not None: write(_filter(_v, rawExpr='${codeString}')) # from line 343, col 1.
        write('''// **********************************************
#undef ''')
        _v = VFFSL(SL,"propagationDimension",True) # u'${propagationDimension}' on line 345, col 8
        if _v is not None: write(_filter(_v, rawExpr='${propagationDimension}')) # from line 345, col 8.
        write('''
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def insideDataLoops(self, **KWS):



        ## CHEETAH: generated from @def insideDataLoops at line 349, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        basis = VFFSL(SL,"vector.initialBasis",True)
        write('''// Save the old initialisation pointer, and clear the new one
_inputfield_old_index_pointer = _inputfield_index_pointer;
_inputfield_index_pointer = 0;

''')
        for dimensionNumber, dimension in enumerate(VFFSL(SL,"vector.field.dimensions",True)): # generated from line 356, col 3
            dimRep = dimension.inBasis(basis)
            dimName = dimRep.name
            write('''_inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 359, col 12
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 359, col 12.
            write(''' = ''')
            #  FIXME: Consider moving this to the dimension representations
            if isinstance(dimRep, UniformDimensionRepresentation): # generated from line 361, col 5
                write('''lround((''')
                _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 362, col 9
                if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 362, col 9.
                write(''' - _inputfield_min_''')
                _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 362, col 38
                if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 362, col 38.
                write(''')/_dimDelta[''')
                _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 362, col 60
                if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 362, col 60.
                write(''']);
''')
            elif isinstance(dimRep, SplitUniformDimensionRepresentation): # generated from line 363, col 5
                write('''lround(''')
                _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 364, col 8
                if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 364, col 8.
                write('''/_dimDelta[''')
                _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 364, col 29
                if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 364, col 29.
                write(''']) + (_inputLattice[''')
                _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 364, col 67
                if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 364, col 67.
                write(''']/2);
''')
            else: # generated from line 365, col 5
                assert False, "XSIL Loading does not support loading data for dimensions that aren't uniformly spaced. The problem is with %s" % dimName
            write('''
// Check if the input grid has this coordinate value
if (_inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 370, col 16
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 370, col 16.
            write(''' < 0 || _inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 370, col 54
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 370, col 54.
            write(''' >= _inputLattice[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 370, col 91
            if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 370, col 91.
            write("""])
  // The input grid doesn't cover this point.
  goto _ENDLOOP;

// check that the input coordinate matches up with a field coordinate
{
  double _inputfield_""")
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 376, col 22
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 376, col 22.
            write(''';
  if (_isPrecisionDouble)
    _inputfield_''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 378, col 17
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 378, col 17.
            write(''' = _inputData[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 378, col 41
            if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 378, col 41.
            write(''']._doublePtr[_inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 378, col 83
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 378, col 83.
            write('''];
  else
    _inputfield_''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 380, col 17
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 380, col 17.
            write(''' = _inputData[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 380, col 41
            if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 380, col 41.
            write(''']._floatPtr[_inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 380, col 82
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 380, col 82.
            write('''];
  
  if (abs(_inputfield_''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 382, col 23
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 382, col 23.
            write(''' - ''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 382, col 36
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 382, col 36.
            write(''') > 0.1*_dimDelta[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'${dimensionNumber}' on line 382, col 64
            if _v is not None: write(_filter(_v, rawExpr='${dimensionNumber}')) # from line 382, col 64.
            write('''])
    // This only happens if your input field grid does not exactly match up with the simulation grid.
    // _LOG will cause the simulation to exit
''')
            dimRepTypeFormat = {'real': 'e', 'long': 'li'}[dimRep.type]
            write('''    _LOG(_ERROR_LOG_LEVEL, "The input field coordinate in the \'''')
            _v = VFFSL(SL,"dimName",True) # u'$dimName' on line 386, col 64
            if _v is not None: write(_filter(_v, rawExpr='$dimName')) # from line 386, col 64.
            write('''\' dimension does not match up with the field coordinate.\\n"
                           "''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 387, col 29
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 387, col 29.
            write(''': %li, ''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 387, col 55
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 387, col 55.
            write(''': %''')
            _v = VFFSL(SL,"dimRepTypeFormat",True) # u'${dimRepTypeFormat}' on line 387, col 68
            if _v is not None: write(_filter(_v, rawExpr='${dimRepTypeFormat}')) # from line 387, col 68.
            write(''', _inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 387, col 100
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 387, col 100.
            write(''': %li, "
                           "_inputfield_''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 388, col 41
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 388, col 41.
            write(''': %e, d''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 388, col 58
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 388, col 58.
            write(''': %e, diff/Delta: %e\\n",
                           ''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 389, col 28
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 389, col 28.
            write(''', ''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 389, col 49
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 389, col 49.
            write(''', _inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 389, col 72
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 389, col 72.
            write(''',
                           _inputfield_''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 390, col 40
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 390, col 40.
            write(''', (real)d''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 390, col 59
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 390, col 59.
            write(''', abs(_inputfield_''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 390, col 87
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 390, col 87.
            write(''' - ''')
            _v = VFFSL(SL,"dimName",True) # u'${dimName}' on line 390, col 100
            if _v is not None: write(_filter(_v, rawExpr='${dimName}')) # from line 390, col 100.
            write(''')/_dimDelta[''')
            _v = VFFSL(SL,"dimensionNumber",True) # u'$dimensionNumber' on line 390, col 122
            if _v is not None: write(_filter(_v, rawExpr='$dimensionNumber')) # from line 390, col 122.
            write(''']);
}

_inputfield_index_pointer += _inputfield''')
            _v = VFFSL(SL,"dimRep.loopIndex",True) # u'${dimRep.loopIndex}' on line 393, col 41
            if _v is not None: write(_filter(_v, rawExpr='${dimRep.loopIndex}')) # from line 393, col 41.
            _v = ''.join([''.join([' * _inputLattice[',str(VFFSL(SL,"i",True)),']']) for i in range(dimensionNumber + 1, len(VFFSL(SL,"vector.field.dimensions",True)))]) # u"${''.join([c' * _inputLattice[$i]' for i in range(dimensionNumber + 1, len($vector.field.dimensions))])}" on line 393, col 60
            if _v is not None: write(_filter(_v, rawExpr="${''.join([c' * _inputLattice[$i]' for i in range(dimensionNumber + 1, len($vector.field.dimensions))])}")) # from line 393, col 60.
            write(''';

''')
        write('''

double _value;
if (_inputfield_index_pointer != _inputfield_old_index_pointer + 1)
  fseeko(_inputFile, _binaryFileBaseOffset + (_componentInputIndices[_component] - _''')
        _v = VFFSL(SL,"vector.field.name",True) # u'${vector.field.name}' on line 400, col 85
        if _v is not None: write(_filter(_v, rawExpr='${vector.field.name}')) # from line 400, col 85.
        write('''_ndims) * _vectorFieldSize
                     + _unsignedLongSize + _inputfield_index_pointer * _realNumberSize, SEEK_SET);

if (_isPrecisionDouble) {
  fread(&_value, sizeof(double), 1, _inputFile);
  if (!_dataEncodingIsNative)
    _value = XMDSSwapDouble(_value);
} else {
  float _temp;
  fread(&_temp, sizeof(float), 1, _inputFile);
  if (!_dataEncodingIsNative)
    _temp = XMDSSwapFloat(_temp);
  _value = (double)_temp;
}

''')
        if VFFSL(SL,"vector.type",True) == 'real': # generated from line 415, col 3
            write('''_active_''')
            _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 416, col 9
            if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 416, col 9.
            write('''[_''')
            _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 416, col 23
            if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 416, col 23.
            write('''_index_pointer + _component] = (real)_value;
''')
        else: # generated from line 417, col 3
            write('''reinterpret_cast<real*>(_active_''')
            _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 418, col 33
            if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 418, col 33.
            write(''')[2*_''')
            _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 418, col 50
            if _v is not None: write(_filter(_v, rawExpr='${vector.id}')) # from line 418, col 50.
            write('''_index_pointer + _component] = (real)_value;
''')
        write('''  
_ENDLOOP:;
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def writeBody(self, **KWS):



        ## CHEETAH: main method generated for this template
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        # VectorInitialisationFromXSIL.tmpl
        # 
        # Created by Graham Dennis on 2008-03-14.
        # 
        # Copyright (c) 2008-2012, Graham Dennis
        # 
        # This program is free software: you can redistribute it and/or modify
        # it under the terms of the GNU General Public License as published by
        # the Free Software Foundation, either version 2 of the License, or
        # (at your option) any later version.
        # 
        # This program is distributed in the hope that it will be useful,
        # but WITHOUT ANY WARRANTY; without even the implied warranty of
        # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        # GNU General Public License for more details.
        # 
        # You should have received a copy of the GNU General Public License
        # along with this program.  If not, see <http://www.gnu.org/licenses/>.
        # 
        write('''







''')
        # 
        #   Initialise a vector
        write('''


''')
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        
    ##################################################
    ## CHEETAH GENERATED ATTRIBUTES


    _CHEETAH__instanceInitialized = False

    _CHEETAH_version = __CHEETAH_version__

    _CHEETAH_versionTuple = __CHEETAH_versionTuple__

    _CHEETAH_genTime = __CHEETAH_genTime__

    _CHEETAH_genTimestamp = __CHEETAH_genTimestamp__

    _CHEETAH_src = __CHEETAH_src__

    _CHEETAH_srcLastModified = __CHEETAH_srcLastModified__

    uselib = ['xmds']

    _mainCheetahMethod_for_VectorInitialisationFromXSIL= 'writeBody'

## END CLASS DEFINITION

if not hasattr(VectorInitialisationFromXSIL, '_initCheetahAttributes'):
    templateAPIClass = getattr(VectorInitialisationFromXSIL, '_CHEETAH_templateClass', Template)
    templateAPIClass._addCheetahPlumbingCodeToClass(VectorInitialisationFromXSIL)


# CHEETAH was developed by Tavis Rudd and Mike Orr
# with code, advice and input from many other volunteers.
# For more information visit http://www.CheetahTemplate.org/

##################################################
## if run from command line:
if __name__ == '__main__':
    from Cheetah.TemplateCmdLineIface import CmdLineIface
    CmdLineIface(templateObj=VectorInitialisationFromXSIL()).run()


