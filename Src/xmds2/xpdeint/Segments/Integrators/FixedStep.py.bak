#!/usr/bin/env python




##################################################
## DEPENDENCIES
import sys
import os
import os.path
try:
    import builtins as builtin
except ImportError:
    import __builtin__ as builtin
from os.path import getmtime, exists
import time
import types
from Cheetah.Version import MinCompatibleVersion as RequiredCheetahVersion
from Cheetah.Version import MinCompatibleVersionTuple as RequiredCheetahVersionTuple
from Cheetah.Template import Template
from Cheetah.DummyTransaction import *
from Cheetah.NameMapper import NotFound, valueForName, valueFromSearchList, valueFromFrameOrSearchList
from Cheetah.CacheRegion import CacheRegion
import Cheetah.Filters as Filters
import Cheetah.ErrorCatchers as ErrorCatchers
from xpdeint.Segments.Integrators._FixedStep import _FixedStep

##################################################
## MODULE CONSTANTS
VFFSL=valueFromFrameOrSearchList
VFSL=valueFromSearchList
VFN=valueForName
currentTime=time.time
__CHEETAH_version__ = '2.4.4'
__CHEETAH_versionTuple__ = (2, 4, 4, 'development', 0)
__CHEETAH_genTime__ = 1484975072.185116
__CHEETAH_genTimestamp__ = 'Sat Jan 21 16:04:32 2017'
__CHEETAH_src__ = '/home/mattias/xmds-2.2.3/admin/staging/xmds-2.2.3/xpdeint/Segments/Integrators/FixedStep.tmpl'
__CHEETAH_srcLastModified__ = 'Sat Feb  4 18:39:07 2012'
__CHEETAH_docstring__ = 'Autogenerated by Cheetah: The Python-Powered Template Engine'

if __CHEETAH_versionTuple__ < RequiredCheetahVersionTuple:
    raise AssertionError(
      'This template was compiled with Cheetah version'
      ' %s. Templates compiled before version %s must be recompiled.'%(
         __CHEETAH_version__, RequiredCheetahVersion))

##################################################
## CLASSES

class FixedStep(_FixedStep):

    ##################################################
    ## CHEETAH GENERATED METHODS


    def __init__(self, *args, **KWs):

        super(FixedStep, self).__init__(*args, **KWs)
        if not self._CHEETAH__instanceInitialized:
            cheetahKWArgs = {}
            allowedKWs = 'searchList namespaces filter filtersLib errorCatcher'.split()
            for k,v in KWs.items():
                if k in allowedKWs: cheetahKWArgs[k] = v
            self._initCheetahInstance(**cheetahKWArgs)
        

    def description(self, **KWS):



        ## Generated from @def description: segment $segmentNumber ($stepper.name fixed-step integrator) at line 24, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        write(u'''segment ''')
        _v = VFFSL(SL,"segmentNumber",True) # u'$segmentNumber' on line 24, col 27
        if _v is not None: write(_filter(_v, rawExpr=u'$segmentNumber')) # from line 24, col 27.
        write(u''' (''')
        _v = VFFSL(SL,"stepper.name",True) # u'$stepper.name' on line 24, col 43
        if _v is not None: write(_filter(_v, rawExpr=u'$stepper.name')) # from line 24, col 43.
        write(u''' fixed-step integrator)''')
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def functionPrototypes(self, **KWS):



        ## CHEETAH: generated from @def functionPrototypes at line 27, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = super(FixedStep, self).functionPrototypes()
        if _v is not None: write(_filter(_v))
        # 
        if VFFSL(SL,"cross",True): # generated from line 31, col 3
            write(u'''void _''')
            _v = VFFSL(SL,"name",True) # u'${name}' on line 32, col 7
            if _v is not None: write(_filter(_v, rawExpr=u'${name}')) # from line 32, col 7.
            write(u'''_initialise_cross_propagation();
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def functionImplementations(self, **KWS):



        ## CHEETAH: generated from @def functionImplementations at line 37, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = super(FixedStep, self).functionImplementations()
        if _v is not None: write(_filter(_v))
        # 
        if VFFSL(SL,"cross",True): # generated from line 41, col 3
            write(u'''
''')
            _v = VFFSL(SL,"initialiseCrossPropagationFunctionImplementation",True) # u'${initialiseCrossPropagationFunctionImplementation}' on line 43, col 1
            if _v is not None: write(_filter(_v, rawExpr=u'${initialiseCrossPropagationFunctionImplementation}')) # from line 43, col 1.
            write(u'''
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def localInitialise(self, **KWS):


        """
        This function returns the local initialisation code for the integrator.
        """

        ## CHEETAH: generated from @def localInitialise at line 49, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = super(FixedStep, self).localInitialise()
        if _v is not None: write(_filter(_v))
        # 
        if VFFSL(SL,"cross",True): # generated from line 56, col 3
            write(u'''
_''')
            _v = VFFSL(SL,"name",True) # u'${name}' on line 58, col 2
            if _v is not None: write(_filter(_v, rawExpr=u'${name}')) # from line 58, col 2.
            write(u'''_initialise_cross_propagation();

''')
            integrationDimRep = VFN(VFN(VFFSL(SL,"parent.field",True),"dimensionWithName",False)(VFFSL(SL,"propagationDimension",True)),"inBasis",False)(VFFSL(SL,"parent.operatorBasis",True))
            if VFFSL(SL,"propagationDirection",True) == '+': # generated from line 61, col 5
                initialValue = integrationDimRep.minimum
            else: # generated from line 63, col 5
                initialValue = integrationDimRep.maximum
            _v = VFFSL(SL,"integrationDimRep.type",True) # u'${integrationDimRep.type}' on line 66, col 1
            if _v is not None: write(_filter(_v, rawExpr=u'${integrationDimRep.type}')) # from line 66, col 1.
            write(u''' ''')
            _v = VFFSL(SL,"integrationDimRep.name",True) # u'${integrationDimRep.name}' on line 66, col 27
            if _v is not None: write(_filter(_v, rawExpr=u'${integrationDimRep.name}')) # from line 66, col 27.
            write(u''' = ''')
            _v = VFFSL(SL,"initialValue",True) # u'${initialValue}' on line 66, col 55
            if _v is not None: write(_filter(_v, rawExpr=u'${initialValue}')) # from line 66, col 55.
            write(u''';
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def createStepVariable(self, **KWS):


        """
        This function returns the code that will create a _step variable,
        including any modifications necessary due to the ErrorCheck feature.
        """

        ## CHEETAH: generated from @def createStepVariable at line 72, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        write(u'''real _step = ''')
        _v = VFFSL(SL,"step",True) # u'${step}' on line 78, col 14
        if _v is not None: write(_filter(_v, rawExpr=u'${step}')) # from line 78, col 14.
        write(u''';
real _noiseStep = ''')
        _v = VFFSL(SL,"step",True) # u'${step}' on line 79, col 19
        if _v is not None: write(_filter(_v, rawExpr=u'${step}')) # from line 79, col 19.
        write(u''';
''')
        # 
        featureOrdering = ['ErrorCheck']
        # 
        _v = VFFSL(SL,"insertCodeForFeatures",False)('createFixedStepVariable', featureOrdering) # u"${insertCodeForFeatures('createFixedStepVariable', featureOrdering)}" on line 83, col 1
        if _v is not None: write(_filter(_v, rawExpr=u"${insertCodeForFeatures('createFixedStepVariable', featureOrdering)}")) # from line 83, col 1.
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def segmentFunctionBody(self, function, **KWS):



        ## CHEETAH: generated from @def segmentFunctionBody($function) at line 88, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        _v = VFFSL(SL,"createStepVariable",True) # u'${createStepVariable}' on line 90, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${createStepVariable}')) # from line 90, col 1.
        # 
        featureOrderingOuter = ['Stochastic']
        _v = VFFSL(SL,"insertCodeForFeatures",False)('integrateFixedStepBegin', featureOrderingOuter) # u"${insertCodeForFeatures('integrateFixedStepBegin', featureOrderingOuter)}" on line 93, col 1
        if _v is not None: write(_filter(_v, rawExpr=u"${insertCodeForFeatures('integrateFixedStepBegin', featureOrderingOuter)}")) # from line 93, col 1.
        write(u'''
''')
        _v = VFFSL(SL,"allocate",True) # u'${allocate}' on line 95, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${allocate}')) # from line 95, col 1.
        _v = VFFSL(SL,"initialise",True) # u'${initialise}' on line 96, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${initialise}')) # from line 96, col 1.
        _v = VFFSL(SL,"localInitialise",True) # u'${localInitialise}' on line 97, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${localInitialise}')) # from line 97, col 1.
        write(u'''
for (long _istep = 0; _istep < ''')
        _v = VFFSL(SL,"stepCount",True) # u'${stepCount}' on line 99, col 32
        if _v is not None: write(_filter(_v, rawExpr=u'${stepCount}')) # from line 99, col 32.
        write(u'''; _istep++) {
''')
        #  Insert code for features
        featureOrderingInner = ['Output', 'ErrorCheck', 'Stochastic']
        # 
        dict = {'extraIndent': 0}
        write(u'''  ''')
        _v = VFFSL(SL,"insertCodeForFeatures",False)('integrateFixedStepInnerLoopBegin', featureOrderingInner, dict) # u"${insertCodeForFeatures('integrateFixedStepInnerLoopBegin', featureOrderingInner, dict), autoIndent=True}" on line 104, col 3
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u"${insertCodeForFeatures('integrateFixedStepInnerLoopBegin', featureOrderingInner, dict), autoIndent=True}")) # from line 104, col 3.
        extraIndent = VFFSL(SL,"dict.extraIndent",True)
        write(u'''  
  ''')
        _v = VFFSL(SL,"preSingleStep",True) # u'${preSingleStep, autoIndent=True, extraIndent=extraIndent}' on line 107, col 3
        if _v is not None: write(_filter(_v, autoIndent=True, extraIndent=extraIndent, rawExpr=u'${preSingleStep, autoIndent=True, extraIndent=extraIndent}')) # from line 107, col 3.
        write(u'''  ''')
        _v = VFN(VFFSL(SL,"stepper",True),"singleIntegrationStep",False)(function) # u'${stepper.singleIntegrationStep(function), autoIndent=True, extraIndent=extraIndent}' on line 108, col 3
        if _v is not None: write(_filter(_v, autoIndent=True, extraIndent=extraIndent, rawExpr=u'${stepper.singleIntegrationStep(function), autoIndent=True, extraIndent=extraIndent}')) # from line 108, col 3.
        write(u'''  ''')
        _v = VFFSL(SL,"postSingleStep",True) # u'${postSingleStep, autoIndent=True, extraIndent=extraIndent}' on line 109, col 3
        if _v is not None: write(_filter(_v, autoIndent=True, extraIndent=extraIndent, rawExpr=u'${postSingleStep, autoIndent=True, extraIndent=extraIndent}')) # from line 109, col 3.
        write(u'''  
''')
        if VFFSL(SL,"cross",True): # generated from line 111, col 3
            #  If we are cross-integrating, then we now need to copy our result back
            #  into the original arrays for the integration vectors
            write(u'''  ''')
            _v = VFFSL(SL,"copyResultIntoIntegrationArrays",True) # u'${copyResultIntoIntegrationArrays, autoIndent=True, extraIndent=extraIndent}' on line 114, col 3
            if _v is not None: write(_filter(_v, autoIndent=True, extraIndent=extraIndent, rawExpr=u'${copyResultIntoIntegrationArrays, autoIndent=True, extraIndent=extraIndent}')) # from line 114, col 3.
            write(u'''  
''')
        # 
        write(u'''  ''')
        _v = VFFSL(SL,"insertCodeForFeaturesInReverseOrder",False)('integrateFixedStepInnerLoopEnd', featureOrderingInner, dict) # u"${insertCodeForFeaturesInReverseOrder('integrateFixedStepInnerLoopEnd', featureOrderingInner, dict), autoIndent=True}" on line 118, col 3
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u"${insertCodeForFeaturesInReverseOrder('integrateFixedStepInnerLoopEnd', featureOrderingInner, dict), autoIndent=True}")) # from line 118, col 3.
        write(u'''}

''')
        _v = VFFSL(SL,"localFinalise",True) # u'${localFinalise}' on line 121, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${localFinalise}')) # from line 121, col 1.
        _v = VFFSL(SL,"finalise",True) # u'${finalise}' on line 122, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${finalise}')) # from line 122, col 1.
        _v = VFFSL(SL,"free",True) # u'${free}' on line 123, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${free}')) # from line 123, col 1.
        write(u'''
''')
        _v = VFFSL(SL,"insertCodeForFeaturesInReverseOrder",False)('integrateFixedStepEnd', featureOrderingOuter) # u"${insertCodeForFeaturesInReverseOrder('integrateFixedStepEnd', featureOrderingOuter)}" on line 125, col 1
        if _v is not None: write(_filter(_v, rawExpr=u"${insertCodeForFeaturesInReverseOrder('integrateFixedStepEnd', featureOrderingOuter)}")) # from line 125, col 1.
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def reducedFieldCopy(self, vectorMap, templateString, positiveIndexOverride=None, negativeIndexOverride=None, **KWS):



        ## CHEETAH: generated from @def reducedFieldCopy($vectorMap, $templateString, $positiveIndexOverride = None, $negativeIndexOverride = None) at line 132, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        if VFFSL(SL,"propagationDirection",True) == '+': # generated from line 134, col 3
            if VFFSL(SL,"positiveIndexOverride",True): # generated from line 135, col 5
                indexOverrideValue = VFFSL(SL,"positiveIndexOverride",True)
            else: # generated from line 137, col 5
                indexOverrideValue = '_istep'
        else: # generated from line 140, col 3
            if VFFSL(SL,"negativeIndexOverride",True): # generated from line 141, col 5
                indexOverrideValue = VFFSL(SL,"negativeIndexOverride",True)
            else: # generated from line 143, col 5
                propDimRep = VFN(VFN(VFFSL(SL,"parent.field",True),"dimensionWithName",False)(VFFSL(SL,"propagationDimension",True)),"inBasis",False)(VFFSL(SL,"parent.operatorBasis",True))
                indexOverrideValue = ''.join([u'(',str(VFFSL(SL,"propDimRep.globalLattice",True)),u' - _istep - 1)'])
        # 
        #  Create the index overrides dictionary. We only need to override the propagation dimension
        indexOverrides = {VFFSL(SL,"propagationDimension",True): dict([(v.field, indexOverrideValue) for v in vectorMap.values()])}
        # 
        setOfVectorsToLoopOver = set(vectorMap.keys())
        setOfVectorsToLoopOver.update(vectorMap.values())
        # 
        innerLoopTemplate = VFFSL(SL,"templateObjectFromStringWithTemplateVariables",False)(VFFSL(SL,"templateString",True), {'componentIndex': '_icomp'})
        # 
        ## START CAPTURE REGION: _32598231 loopContents at line 157, col 3 in the source.
        _orig_trans_32598231 = trans
        _wasBuffering_32598231 = self._CHEETAH__isBuffering
        self._CHEETAH__isBuffering = True
        trans = _captureCollector_32598231 = DummyTransaction()
        write = _captureCollector_32598231.response().write
        for reducedVector, vector in VFN(VFFSL(SL,"vectorMap",True),"iteritems",False)(): # generated from line 158, col 5
            if vector.field.hasDimensionName(VFFSL(SL,"propagationDimension",True)): # generated from line 159, col 7
                propagationDimensionObject = vector.field.dimensionWithName(VFFSL(SL,"propagationDimension",True))
                innerLoopTemplate.skipSize = VFFSL(SL,"propagationDirection",True) +                                              VFN(VFFSL(SL,"vector.field",True),"localPointsInDimensionsAfterDimRepInBasis",False)(propagationDimensionObject.inBasis(VFFSL(SL,"homeBasis",True)), VFFSL(SL,"homeBasis",True))
            innerLoopTemplate.reducedVector = reducedVector
            innerLoopTemplate.vector = vector
            write(u'''for (long _icomp = 0; _icomp < _''')
            _v = VFFSL(SL,"vector.id",True) # u'${vector.id}' on line 166, col 33
            if _v is not None: write(_filter(_v, rawExpr=u'${vector.id}')) # from line 166, col 33.
            write(u'''_ncomponents; _icomp++) {
  ''')
            _v = VFFSL(SL,"innerLoopTemplate",True) # u'${innerLoopTemplate, autoIndent=True}' on line 167, col 3
            if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u'${innerLoopTemplate, autoIndent=True}')) # from line 167, col 3.
            write(u'''}
''')
            del innerLoopTemplate.skipSize
        trans = _orig_trans_32598231
        write = trans.response().write
        self._CHEETAH__isBuffering = _wasBuffering_32598231 
        loopContents = _captureCollector_32598231.response().getvalue()
        del _orig_trans_32598231
        del _captureCollector_32598231
        del _wasBuffering_32598231
        # 
        _v = VFFSL(SL,"loopOverFieldInBasisWithVectorsAndInnerContent",False)(VFFSL(SL,"parent.reducedField",True), VFFSL(SL,"homeBasis",True), VFFSL(SL,"setOfVectorsToLoopOver",True),
                                                 VFFSL(SL,"loopContents",True), indexOverrides = VFFSL(SL,"indexOverrides",True),
                                                 vectorsNotNeedingDefines = VFFSL(SL,"setOfVectorsToLoopOver",True))
        if _v is not None: write(_filter(_v, rawExpr=u'${loopOverFieldInBasisWithVectorsAndInnerContent($parent.reducedField, $homeBasis, $setOfVectorsToLoopOver,\n                                                 $loopContents, indexOverrides = $indexOverrides,\n                                                 vectorsNotNeedingDefines = $setOfVectorsToLoopOver)}')) # from line 173, col 1.
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def initialiseCrossPropagationFunctionImplementation(self, **KWS):


        """
        Return code for initialising the boundary conditions of a cross-propagation integrator.
        
          This code both sets the boundary conditions and copies in the first values for the
          dependencies into the local dependency arrays.
        """

        ## CHEETAH: generated from @def initialiseCrossPropagationFunctionImplementation at line 180, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        write(u'''void _''')
        _v = VFFSL(SL,"name",True) # u'${name}' on line 188, col 7
        if _v is not None: write(_filter(_v, rawExpr=u'${name}')) # from line 188, col 7.
        write(u'''_initialise_cross_propagation()
{
''')
        positiveIndexOverride = '0'
        basis = VFFSL(SL,"parent.operatorBasis",True)
        propDimRep = VFN(VFN(VFFSL(SL,"parent.field",True),"dimensionWithName",False)(VFFSL(SL,"propagationDimension",True)),"inBasis",False)(basis)
        negativeIndexOverride = ''.join([u'(',str(VFFSL(SL,"propDimRep.globalLattice",True)),u' - 1)'])
        # 
        combinedLoopVectorMap = VFN(VFFSL(SL,"integrationVectorMap",True),"copy",False)()
        combinedLoopVectorMap.update(VFFSL(SL,"dependencyMap",True))
        # 
        vectorsNeedingTransforms = set(combinedLoopVectorMap.values())
        boundaryConditionDependencies = VFN(VFN(VFFSL(SL,"parent",True),"codeBlocks",True)['boundaryCondition'],"dependencies",True)
        vectorsNeedingTransforms.update(boundaryConditionDependencies)
        write(u'''  ''')
        _v = VFFSL(SL,"transformVectorsToBasis",False)(vectorsNeedingTransforms, basis) # u'${transformVectorsToBasis(vectorsNeedingTransforms, basis), autoIndent=True}' on line 201, col 3
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u'${transformVectorsToBasis(vectorsNeedingTransforms, basis), autoIndent=True}')) # from line 201, col 3.
        write(u'''  
''')
        if VFFSL(SL,"propagationDirection",True) == '+': # generated from line 203, col 3
            index = VFFSL(SL,"positiveIndexOverride",True)
        else: # generated from line 205, col 3
            index = VFFSL(SL,"negativeIndexOverride",True)
        write(u'''  real ''')
        _v = VFFSL(SL,"propagationDimension",True) # u'$propagationDimension' on line 208, col 8
        if _v is not None: write(_filter(_v, rawExpr=u'$propagationDimension')) # from line 208, col 8.
        write(u''' = ''')
        _v = VFFSL(SL,"propDimRep.arrayName",True) # u'${propDimRep.arrayName}' on line 208, col 32
        if _v is not None: write(_filter(_v, rawExpr=u'${propDimRep.arrayName}')) # from line 208, col 32.
        write(u'''[''')
        _v = VFFSL(SL,"index",True) # u'$index' on line 208, col 56
        if _v is not None: write(_filter(_v, rawExpr=u'$index')) # from line 208, col 56.
        write(u'''];
  
  // Copy the initial value of the cross-propagation integration vectors and dependencies into our local arrays
  {
    ''')
        _v = VFFSL(SL,"reducedFieldCopy",False)(combinedLoopVectorMap,
"""_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex}];
""", positiveIndexOverride = VFFSL(SL,"positiveIndexOverride",True), negativeIndexOverride = VFFSL(SL,"negativeIndexOverride",True))
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u'${reducedFieldCopy(combinedLoopVectorMap,\n"""_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex}];\n""", positiveIndexOverride = $positiveIndexOverride, negativeIndexOverride = $negativeIndexOverride), autoIndent=True}')) # from line 212, col 5.
        for reducedVector in VFN(VFFSL(SL,"combinedLoopVectorMap",True),"keys",False)(): # generated from line 215, col 5
            if VFFSL(SL,"reducedVector.needsTransforms",True): # generated from line 216, col 7
                write(u'''      _''')
                _v = VFFSL(SL,"reducedVector.id",True) # u'${reducedVector.id}' on line 217, col 8
                if _v is not None: write(_filter(_v, rawExpr=u'${reducedVector.id}')) # from line 217, col 8.
                write(u'''_basis = ''')
                _v = VFFSL(SL,"basisIndexForBasis",False)(VFN(VFFSL(SL,"reducedVector.field",True),"basisForBasis",False)(VFFSL(SL,"basis",True))) # u'$basisIndexForBasis($reducedVector.field.basisForBasis($basis))' on line 217, col 36
                if _v is not None: write(_filter(_v, rawExpr=u'$basisIndexForBasis($reducedVector.field.basisForBasis($basis))')) # from line 217, col 36.
                write(u'''; 
''')
        write(u'''  }
  
''')
        # 
        write(u'''  // Set the boundary condition
  {
    ''')
        _v = VFN(VFN(VFFSL(SL,"parent",True),"codeBlocks",True)['boundaryCondition'],"loop",False)(self.boundaryConditionCode) # u"${parent.codeBlocks['boundaryCondition'].loop(self.boundaryConditionCode), autoIndent=True}" on line 225, col 5
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u"${parent.codeBlocks['boundaryCondition'].loop(self.boundaryConditionCode), autoIndent=True}")) # from line 225, col 5.
        write(u'''  }

  // Copy the initial value of the integration vectors back into their main arrays
  {
    ''')
        _v = VFFSL(SL,"reducedFieldCopy",False)(VFFSL(SL,"integrationVectorMap",True),
"""_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex}];
""", positiveIndexOverride = VFFSL(SL,"positiveIndexOverride",True), negativeIndexOverride = VFFSL(SL,"negativeIndexOverride",True))
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u'${reducedFieldCopy($integrationVectorMap,\n"""_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex}];\n""", positiveIndexOverride = $positiveIndexOverride, negativeIndexOverride = $negativeIndexOverride), autoIndent=True}')) # from line 230, col 5.
        write(u'''  }
  
}
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def boundaryConditionCode(self, codeString, **KWS):



        ## CHEETAH: generated from @def boundaryConditionCode($codeString) at line 239, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        write(u'''// ********** Boundary condition code ***********
''')
        _v = VFFSL(SL,"codeString",True) # u'${codeString}' on line 242, col 1
        if _v is not None: write(_filter(_v, rawExpr=u'${codeString}')) # from line 242, col 1.
        write(u'''// **********************************************
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def copyResultIntoIntegrationArrays(self, **KWS):


        """
        Returns code to copy the result of our cross-propagation step back into the original arrays
          for the integation vectors.
        """

        ## CHEETAH: generated from @def copyResultIntoIntegrationArrays at line 248, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        write(u'''// Copy the result back into the original array.
{
  ''')
        _v = VFFSL(SL,"reducedFieldCopy",False)(VFFSL(SL,"integrationVectorMap",True), 
"""
_active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex} + ${skipSize} * _${vector.id}_ncomponents] = \
  _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}];
""")
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u'${reducedFieldCopy($integrationVectorMap, \n"""\n_active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex} + ${skipSize} * _${vector.id}_ncomponents] = \\\n  _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}];\n"""), autoIndent=True}')) # from line 256, col 3.
        write(u'''}
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def updateDependenciesForNextStep(self, **KWS):


        """
        Return code to update our dependencies vectors from the originals for the next step.
        """

        ## CHEETAH: generated from @def updateDependenciesForNextStep at line 266, col 1.
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        write(u'''// Update the dependencies for the next step
{
  ''')
        _v = VFFSL(SL,"reducedFieldCopy",False)(VFFSL(SL,"dependencyMap",True),
"""
_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = \
  _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex} + ${skipSize} * _${vector.id}_ncomponents];
""")
        if _v is not None: write(_filter(_v, autoIndent=True, rawExpr=u'${reducedFieldCopy($dependencyMap,\n"""\n_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = \\\n  _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex} + ${skipSize} * _${vector.id}_ncomponents];\n"""), autoIndent=True}')) # from line 273, col 3.
        write(u'''}
''')
        # 
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        

    def writeBody(self, **KWS):



        ## CHEETAH: main method generated for this template
        trans = KWS.get("trans")
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        # FixedStep.tmpl
        # 
        # Created by Graham Dennis on 2007-10-20.
        # 
        # Copyright (c) 2007-2012, Graham Dennis
        # 
        # This program is free software: you can redistribute it and/or modify
        # it under the terms of the GNU General Public License as published by
        # the Free Software Foundation, either version 2 of the License, or
        # (at your option) any later version.
        # 
        # This program is distributed in the hope that it will be useful,
        # but WITHOUT ANY WARRANTY; without even the implied warranty of
        # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        # GNU General Public License for more details.
        # 
        # You should have received a copy of the GNU General Public License
        # along with this program.  If not, see <http://www.gnu.org/licenses/>.
        # 
        write(u'''










''')
        #  ---- Cross-propagation methods ----
        write(u'''








''')
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        
    ##################################################
    ## CHEETAH GENERATED ATTRIBUTES


    _CHEETAH__instanceInitialized = False

    _CHEETAH_version = __CHEETAH_version__

    _CHEETAH_versionTuple = __CHEETAH_versionTuple__

    _CHEETAH_genTime = __CHEETAH_genTime__

    _CHEETAH_genTimestamp = __CHEETAH_genTimestamp__

    _CHEETAH_src = __CHEETAH_src__

    _CHEETAH_srcLastModified = __CHEETAH_srcLastModified__

    _mainCheetahMethod_for_FixedStep= 'writeBody'

## END CLASS DEFINITION

if not hasattr(FixedStep, '_initCheetahAttributes'):
    templateAPIClass = getattr(FixedStep, '_CHEETAH_templateClass', Template)
    templateAPIClass._addCheetahPlumbingCodeToClass(FixedStep)


# CHEETAH was developed by Tavis Rudd and Mike Orr
# with code, advice and input from many other volunteers.
# For more information visit http://www.CheetahTemplate.org/

##################################################
## if run from command line:
if __name__ == '__main__':
    from Cheetah.TemplateCmdLineIface import CmdLineIface
    CmdLineIface(templateObj=FixedStep()).run()


