\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{argparse}
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{torch.nn} \PYG{k+kn}{as} \PYG{n+nn}{nn}
\PYG{k+kn}{import} \PYG{n+nn}{torch.nn.functional} \PYG{k+kn}{as} \PYG{n+nn}{F}
\PYG{k+kn}{import} \PYG{n+nn}{torch.optim} \PYG{k+kn}{as} \PYG{n+nn}{optim}
\PYG{k+kn}{import} \PYG{n+nn}{torch.utils.data} \PYG{k+kn}{as} \PYG{n+nn}{data\PYGZus{}utils}
\PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{datasets}\PYG{p}{,} \PYG{n}{transforms}
\PYG{k+kn}{from} \PYG{n+nn}{torch.autograd} \PYG{k+kn}{import} \PYG{n}{Variable}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{readmnistdata} \PYG{k+kn}{as} \PYG{n+nn}{rm}
\PYG{k+kn}{import} \PYG{n+nn}{sampletrainloader} \PYG{k+kn}{as} \PYG{n+nn}{tl}
\PYG{k+kn}{import} \PYG{n+nn}{analyzer} \PYG{k+kn}{as} \PYG{n+nn}{an}
\PYG{k+kn}{import} \PYG{n+nn}{os.path}

\PYG{c+c1}{\PYGZsh{} Training settings}
\PYG{n}{parser} \PYG{o}{=} \PYG{n}{argparse}\PYG{o}{.}\PYG{n}{ArgumentParser}\PYG{p}{(}\PYG{n}{description}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}Fully Connected FeedForwardNetwork for nonlinearSE\PYGZsq{}}\PYG{p}{)}

\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}batch\PYGZhy{}size\PYGZsq{}}\PYG{p}{,}        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,}                 \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}N\PYGZsq{}}\PYG{p}{,}    \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}input batch size for training (default: 64)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}test\PYGZhy{}batch\PYGZhy{}size\PYGZsq{}}\PYG{p}{,}   \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{2000}\PYG{p}{,}               \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}N\PYGZsq{}}\PYG{p}{,}    \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}input batch size for testing (default: 1000)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}epochs\PYGZsq{}}\PYG{p}{,}            \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,}                 \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}N\PYGZsq{}}\PYG{p}{,}    \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}number of epochs to train (default: 10)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}lr\PYGZsq{}}\PYG{p}{,}                \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{,}           \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,}              \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}LR\PYGZsq{}}\PYG{p}{,}   \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}learning rate (default: 0.01)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}momentum\PYGZsq{}}\PYG{p}{,}          \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{,}           \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,}                \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}M\PYGZsq{}}\PYG{p}{,}    \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}SGD momentum (default: 0.5)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}no\PYGZhy{}cuda\PYGZsq{}}\PYG{p}{,}           \PYG{n}{action}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}store\PYGZus{}true\PYGZsq{}}\PYG{p}{,}  \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,}                              \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}disables CUDA training\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}seed\PYGZsq{}}\PYG{p}{,}              \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}                  \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}S\PYGZsq{}}\PYG{p}{,}    \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}random seed (default: 1)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}log\PYGZhy{}interval\PYGZsq{}}\PYG{p}{,}      \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}                 \PYG{n}{metavar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}N\PYGZsq{}}\PYG{p}{,}    \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}how many batches to wait before logging training status\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}network\PYGZhy{}arch\PYGZsq{}}\PYG{p}{,}      \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{128}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{],}   \PYG{n}{nargs}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}+\PYGZsq{}}\PYG{p}{,}  \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Network arch : (default: 256\PYGZhy{}40\PYGZhy{}20\PYGZhy{}1)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}training\PYGZhy{}len\PYGZsq{}}\PYG{p}{,}      \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{8500}\PYG{p}{,}                               \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Training len (default: 3500)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}test\PYGZhy{}len\PYGZsq{}}\PYG{p}{,}          \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{1500}\PYG{p}{,}                                \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Test len (default: 500)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}runtime\PYGZhy{}count\PYGZsq{}}\PYG{p}{,}     \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}                                  \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}this parameter counts that how many times the program is runned\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}show\PYGZhy{}progress\PYGZsq{}}\PYG{p}{,}     \PYG{n}{action}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}store\PYGZus{}true\PYGZsq{}}\PYG{p}{,}  \PYG{n}{default}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,}                              \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}display progress (default:False)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}data\PYGZhy{}file\PYGZsq{}}\PYG{p}{,}         \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}potential\PYGZhy{}g\PYGZhy{}10\PYGZhy{}.dat\PYGZdq{}}\PYG{p}{,}              \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}data file to read (default = \PYGZdq{}potential.dat\PYGZdq{})\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}label\PYGZhy{}file\PYGZsq{}}\PYG{p}{,}        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{,}             \PYG{n}{default}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}energy\PYGZhy{}g\PYGZhy{}10\PYGZhy{}.dat\PYGZdq{}}\PYG{p}{,}                 \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}label file to read (default = \PYGZdq{}energy.dat\PYGZdq{})\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}inter\PYGZhy{}param\PYGZsq{}}\PYG{p}{,}       \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{,}           \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}                                \PYG{n}{help} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}interaction parameter program uses this parameter to choose which file to open (default: 0)\PYGZsq{}}\PYG{p}{)}

\PYG{n}{args} \PYG{o}{=} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{()}
\PYG{n}{args}\PYG{o}{.}\PYG{n}{cuda} \PYG{o}{=} \PYG{o+ow}{not} \PYG{n}{args}\PYG{o}{.}\PYG{n}{no\PYGZus{}cuda} \PYG{o+ow}{and} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{is\PYGZus{}available}\PYG{p}{()}

\PYG{n}{torch}\PYG{o}{.}\PYG{n}{manual\PYGZus{}seed}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{:}
    \PYG{n}{torch}\PYG{o}{.}\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{manual\PYGZus{}seed}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{)}

\PYG{n}{kwargs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}num\PYGZus{}workers\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}pin\PYGZus{}memory\PYGZsq{}}\PYG{p}{:} \PYG{n+nb+bp}{True}\PYG{p}{\PYGZcb{}} \PYG{k}{if} \PYG{n}{args}\PYG{o}{.}\PYG{n}{cuda} \PYG{k}{else} \PYG{p}{\PYGZob{}\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{}input\PYGZus{}size, hidden\PYGZus{}size, hidden2\PYGZus{}size, num\PYGZus{}classes = args.network\PYGZus{}arch}
\PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden2\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden3\PYGZus{}size}\PYG{p}{,} \PYG{n}{num\PYGZus{}classes} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{network\PYGZus{}arch}
\PYG{n}{num\PYGZus{}epochs} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{epochs}
\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size}
\PYG{n}{learning\PYGZus{}rate} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{lr}
\PYG{n}{training\PYGZus{}len} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{training\PYGZus{}len}
\PYG{n}{test\PYGZus{}len} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{test\PYGZus{}len}
\PYG{n}{data\PYGZus{}file} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{data\PYGZus{}file}
\PYG{n}{label\PYGZus{}file} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{label\PYGZus{}file}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{inter\PYGZus{}param}\PYG{p}{)}\PYG{o}{.}\PYG{n}{is\PYGZus{}integer}\PYG{p}{():}
    \PYG{n}{args}\PYG{o}{.}\PYG{n}{inter\PYGZus{}param} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{inter\PYGZus{}param}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}FFN running, Interaction param: \PYGZob{}\PYGZcb{}\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{inter\PYGZus{}param}\PYG{p}{))}

\PYG{n}{data\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}potential\PYGZhy{}g\PYGZhy{}\PYGZob{}\PYGZcb{}\PYGZhy{}.dat\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{inter\PYGZus{}param}\PYG{p}{)}
\PYG{n}{label\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}energy\PYGZhy{}g\PYGZhy{}\PYGZob{}\PYGZcb{}\PYGZhy{}.dat\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{inter\PYGZus{}param}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{tl}\PYG{o}{.}\PYG{n}{nonlinear1D}\PYG{p}{(}\PYG{n}{data\PYGZus{}file}\PYG{p}{,} \PYG{n}{label\PYGZus{}file}\PYG{p}{,} \PYG{n}{training\PYGZus{}len}\PYG{p}{,} \PYG{n}{test\PYGZus{}len}\PYG{p}{)}
\PYG{n}{train\PYGZus{}dataset}\PYG{p}{,} \PYG{n}{test\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{t}\PYG{o}{.}\PYG{n}{init\PYGZus{}tensor\PYGZus{}dataset}\PYG{p}{()}

\PYG{n}{train\PYGZus{}loader} \PYG{o}{=} \PYG{n}{data\PYGZus{}utils}\PYG{o}{.}\PYG{n}{DataLoader}\PYG{p}{(}\PYG{n}{train\PYGZus{}dataset}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{shuffle}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{o}{**}\PYG{n}{kwargs}\PYG{p}{)}
\PYG{n}{test\PYGZus{}loader} \PYG{o}{=} \PYG{n}{data\PYGZus{}utils}\PYG{o}{.}\PYG{n}{DataLoader}\PYG{p}{(}\PYG{n}{test\PYGZus{}dataset}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{test\PYGZus{}batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{shuffle}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{o}{**}\PYG{n}{kwargs}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{Net}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{):}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{num\PYGZus{}classes}\PYG{p}{):}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{Net}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{()}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{relu} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{ReLU}\PYG{p}{()}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc2} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden2\PYGZus{}size}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc3} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{n}{hidden2\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden3\PYGZus{}size}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc4} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{n}{hidden3\PYGZus{}size}\PYG{p}{,} \PYG{n}{num\PYGZus{}classes}\PYG{p}{)}


    \PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{):}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc2}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc3}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{n}{out} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc4}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{out}



\PYG{n}{net} \PYG{o}{=} \PYG{n}{Net}\PYG{p}{(}\PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{num\PYGZus{}classes}\PYG{p}{)}
\PYG{n}{criterion} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{MSELoss}\PYG{p}{()}
\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{optim}\PYG{o}{.}\PYG{n}{Adam}\PYG{p}{(}\PYG{n}{net}\PYG{o}{.}\PYG{n}{parameters}\PYG{p}{(),} \PYG{n}{lr}\PYG{o}{=}\PYG{n}{learning\PYGZus{}rate}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{an}\PYG{o}{.}\PYG{n}{analyzer}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{train}\PYG{p}{(}\PYG{n}{epoch}\PYG{p}{):}
    \PYG{k}{for} \PYG{n}{batch\PYGZus{}idx}\PYG{p}{,} \PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{train\PYGZus{}loader}\PYG{p}{):}
        \PYG{n}{data} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{n}{labels} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{)}\PYG{o}{.}\PYG{n}{float}\PYG{p}{()}
        \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{zero\PYGZus{}grad}\PYG{p}{()}
        \PYG{n}{outputs} \PYG{o}{=} \PYG{n}{net}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{n}{loss} \PYG{o}{=} \PYG{n}{criterion}\PYG{p}{(}\PYG{n}{outputs}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)}
        \PYG{n}{loss}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{()}
        \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{step}\PYG{p}{()}

\PYG{c+c1}{\PYGZsh{}        if (i) \PYGZpc{} res.batch\PYGZus{}size == 0 and args.show\PYGZus{}progress == True:}
\PYG{c+c1}{\PYGZsh{}            print(\PYGZsq{}Epoch [\PYGZpc{}d/\PYGZpc{}d], Step [\PYGZpc{}d/\PYGZpc{}d], Loss: \PYGZpc{}.4f\PYGZsq{} \PYGZpc{}(res.cur\PYGZus{}epoch, res.epochs, i, res.training\PYGZus{}len // res.batch\PYGZus{}size, loss.data[0]))}
\PYG{c+c1}{\PYGZsh{}            res.step(loss.data[0])}

        \PYG{k}{if} \PYG{n}{batch\PYGZus{}idx} \PYG{o}{\PYGZpc{}} \PYG{n}{args}\PYG{o}{.}\PYG{n}{log\PYGZus{}interval} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{args}\PYG{o}{.}\PYG{n}{show\PYGZus{}progress} \PYG{o}{==} \PYG{n+nb+bp}{True}\PYG{p}{:}
            \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Train Epoch: \PYGZob{}\PYGZcb{} [\PYGZob{}\PYGZcb{}/\PYGZob{}\PYGZcb{} (\PYGZob{}:.0f\PYGZcb{}\PYGZpc{})]}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{Loss: \PYGZob{}:.6f\PYGZcb{}\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}
                \PYG{n}{epoch}\PYG{p}{,} \PYG{n}{batch\PYGZus{}idx} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{),} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{train\PYGZus{}loader}\PYG{o}{.}\PYG{n}{dataset}\PYG{p}{),}
                \PYG{l+m+mf}{100.} \PYG{o}{*} \PYG{n}{batch\PYGZus{}idx} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{train\PYGZus{}loader}\PYG{p}{),} \PYG{n}{loss}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]))}

    \PYG{n}{res}\PYG{o}{.}\PYG{n}{step}\PYG{p}{(}\PYG{n}{loss}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{])}


\PYG{n}{info\PYGZus{}file\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}../figs/FFNTEST/\PYGZdq{}} \PYG{o}{+} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{splitext}\PYG{p}{(}\PYG{n}{data\PYGZus{}file}\PYG{p}{)[}\PYG{l+m+mi}{0}\PYG{p}{]}


\PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{():}
    \PYG{k}{for} \PYG{n}{data}\PYG{p}{,} \PYG{n}{labels} \PYG{o+ow}{in} \PYG{n}{test\PYGZus{}loader}\PYG{p}{:}
        \PYG{n}{data} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{n}{outputs} \PYG{o}{=} \PYG{n}{net}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{n}{predicted} \PYG{o}{=} \PYG{n}{outputs}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{()}
        \PYG{n}{real} \PYG{o}{=} \PYG{n}{test\PYGZus{}dataset}\PYG{o}{.}\PYG{n}{target\PYGZus{}tensor}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{()}
        \PYG{n}{real} \PYG{o}{=} \PYG{n}{real}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{([}\PYG{n}{test\PYGZus{}len}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{])}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{calc\PYGZus{}error}\PYG{p}{(}\PYG{n}{real}\PYG{p}{,} \PYG{n}{predicted}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}res.display\PYGZus{}plot()}

\PYG{c+c1}{\PYGZsh{}        global info\PYGZus{}file\PYGZus{}name}
\PYG{c+c1}{\PYGZsh{}        file\PYGZus{}name = info\PYGZus{}file\PYGZus{}name + \PYGZdq{}epoch\PYGZhy{}\PYGZob{}\PYGZcb{}\PYGZhy{}.inf\PYGZdq{}.format(res.cur\PYGZus{}epoch)}
\PYG{c+c1}{\PYGZsh{}        an.save\PYGZus{}info(res, file\PYGZus{}name)}

    \PYG{k}{return} \PYG{n}{predicted}

\PYG{k}{while} \PYG{n}{res}\PYG{o}{.}\PYG{n}{cur\PYGZus{}epoch} \PYG{o}{!=} \PYG{n}{res}\PYG{o}{.}\PYG{n}{epochs} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{train}\PYG{p}{(}\PYG{n}{res}\PYG{o}{.}\PYG{n}{cur\PYGZus{}epoch}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}    if res.cur\PYGZus{}epoch \PYGZpc{} (res.epochs / 3) == 0:}
\PYG{c+c1}{\PYGZsh{}        test()}
    \PYG{n}{res}\PYG{o}{.}\PYG{n}{cur\PYGZus{}epoch} \PYG{o}{+=}\PYG{l+m+mi}{1}

\PYG{n}{res}\PYG{o}{.}\PYG{n}{cur\PYGZus{}epoch} \PYG{o}{=} \PYG{n}{res}\PYG{o}{.}\PYG{n}{epochs}
\PYG{n}{test}\PYG{p}{()}
\end{Verbatim}
